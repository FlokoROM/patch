diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index 0471bf8bee1f..475e0f4cb05b 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -818,57 +818,8 @@ public class ApplicationPackageManager extends PackageManager {
                 }
             };
 
-    private static final String[] p21Codenames = {
-            "cheetah",
-            "panther",
-            "bluejay",
-            "oriole",
-            "raven"
-    };
-
-    private static final String[] featuresPixel = {
-            "com.google.android.apps.photos.PIXEL_2019_PRELOAD",
-            "com.google.android.apps.photos.PIXEL_2019_MIDYEAR_PRELOAD",
-            "com.google.android.apps.photos.PIXEL_2018_PRELOAD",
-            "com.google.android.apps.photos.PIXEL_2017_PRELOAD",
-            "com.google.android.feature.PIXEL_2020_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2020_MIDYEAR_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2019_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2019_MIDYEAR_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2018_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2017_EXPERIENCE",
-            "com.google.android.feature.PIXEL_EXPERIENCE",
-            "com.google.android.feature.GOOGLE_BUILD",
-            "com.google.android.feature.GOOGLE_EXPERIENCE"
-    };
-
-    private static final String[] featuresP21 = {
-            "com.google.android.feature.PIXEL_2022_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2022_MIDYEAR_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2021_EXPERIENCE",
-            "com.google.android.feature.PIXEL_2021_MIDYEAR_EXPERIENCE"
-    };
-
-    private static final String[] featuresNexus = {
-            "com.google.android.apps.photos.NEXUS_PRELOAD",
-            "com.google.android.apps.photos.nexus_preload"
-    };
-
     @Override
     public boolean hasSystemFeature(String name, int version) {
-        String packageName = ActivityThread.currentPackageName();
-        if (packageName != null &&
-                packageName.equals("com.google.android.apps.photos") &&
-                SystemProperties.getBoolean("persist.sys.pixelprops.gphotos", true)) {
-            if (Arrays.asList(featuresPixel).contains(name)) return false;
-            if (Arrays.asList(featuresP21).contains(name)) return false;
-            if (Arrays.asList(featuresNexus).contains(name)) return true;
-        }
-        if (Arrays.asList(featuresPixel).contains(name)) return true;
-        if (Arrays.asList(featuresP21).contains(name) &&
-                !Arrays.asList(p21Codenames).contains(SystemProperties.get("ro.product.device"))) {
-            return false;
-        }
         return mHasSystemFeatureCache.query(new HasSystemFeatureQuery(name, version));
     }
 
diff --git a/core/java/android/app/Instrumentation.java b/core/java/android/app/Instrumentation.java
index be258caa1fb1..556058b567f9 100644
--- a/core/java/android/app/Instrumentation.java
+++ b/core/java/android/app/Instrumentation.java
@@ -64,8 +64,6 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeoutException;
 
-import com.android.internal.util.crdroid.PixelPropsUtils;
-
 /**
  * Base class for implementing application instrumentation code.  When running
  * with instrumentation turned on, this class will be instantiated for you
@@ -1244,8 +1242,6 @@ public class Instrumentation {
         Application app = getFactory(context.getPackageName())
                 .instantiateApplication(cl, className);
         app.attach(context);
-        String packageName = context.getPackageName();
-        PixelPropsUtils.setProps(packageName);
         return app;
     }
     
@@ -1263,8 +1259,6 @@ public class Instrumentation {
             ClassNotFoundException {
         Application app = (Application)clazz.newInstance();
         app.attach(context);
-        String packageName = context.getPackageName();
-        PixelPropsUtils.setProps(packageName);
         return app;
     }
 
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index a8efdc447808..c9f2777db330 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -12045,12 +12045,6 @@ public final class Settings {
          */
         public static final String SHOW_CLIPBOARD_OVERLAY = "show_clipboard_overlay";
 
-        /**
-         * Face Unlock Method
-         * @hide
-         */
-        public static final String FACE_UNLOCK_METHOD = "face_unlock_method";
-
         /**
          * Control whether GMS is enabled for this user.
          * @hide
diff --git a/core/java/com/android/internal/util/crdroid/PixelPropsUtils.java b/core/java/com/android/internal/util/crdroid/PixelPropsUtils.java
deleted file mode 100644
index 3505804b7c27..000000000000
--- a/core/java/com/android/internal/util/crdroid/PixelPropsUtils.java
+++ /dev/null
@@ -1,410 +0,0 @@
-/*
- * Copyright (C) 2020 The Pixel Experience Project
- *               2021-2022 crDroid Android Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.internal.util.crdroid;
-
-import android.app.Application;
-import android.os.Build;
-import android.os.SystemProperties;
-import android.util.Log;
-
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-public class PixelPropsUtils {
-
-    private static final String TAG = PixelPropsUtils.class.getSimpleName();
-    private static final String DEVICE = "ro.product.device";
-    private static final boolean DEBUG = false;
-
-    private static final Map<String, Object> propsToChangePixel5;
-    private static final Map<String, Object> propsToChangePixel7Pro;
-    private static final Map<String, Object> propsToChangePixelXL;
-    private static final Map<String, Object> propsToChangeROG1;
-    private static final Map<String, Object> propsToChangeROG3;
-    private static final Map<String, Object> propsToChangeXP5;
-    private static final Map<String, Object> propsToChangeOP8P;
-    private static final Map<String, Object> propsToChangeOP9R;
-    private static final Map<String, Object> propsToChange11T;
-    private static final Map<String, Object> propsToChangeF4;
-    private static final Map<String, ArrayList<String>> propsToKeep;
-
-    // Packages to Spoof as Pixel 7 Pro
-    private static final String[] packagesToChangePixel7Pro = {
-            "com.google.android.apps.wallpaper",
-            "com.google.android.apps.privacy.wildlife",
-            "com.google.android.apps.subscriptions.red",
-            "com.google.android.inputmethod.latin"
-    };
-
-    // Packages to Spoof as Pixel XL
-    private static final String[] packagesToChangePixelXL = {
-            "com.samsung.accessory",
-            "com.samsung.accessory.fridaymgr",
-            "com.samsung.accessory.berrymgr",
-            "com.samsung.accessory.neobeanmgr",
-            "com.samsung.android.app.watchmanager",
-            "com.samsung.android.geargplugin",
-            "com.samsung.android.gearnplugin",
-            "com.samsung.android.modenplugin",
-            "com.samsung.android.neatplugin",
-            "com.samsung.android.waterplugin"
-    };
-
-    // Packages to Spoof as Pixel 7 Pro
-    private static final String[] extraPackagesToChange = {
-            "com.android.chrome",
-            "com.android.vending",
-            "com.breel.wallpapers20",
-            "com.nhs.online.nhsonline",
-            "com.netflix.mediaclient"
-    };
-
-    // Packages to Keep with original device
-    private static final String[] packagesToKeep = {
-            "com.google.android.GoogleCamera",
-            "com.google.android.GoogleCamera.Cameight",
-            "com.google.android.GoogleCamera.Go",
-            "com.google.android.GoogleCamera.Urnyx",
-            "com.google.android.GoogleCameraAsp",
-            "com.google.android.GoogleCameraCVM",
-            "com.google.android.GoogleCameraEng",
-            "com.google.android.GoogleCameraEng2",
-            "com.google.android.GoogleCameraGood",
-            "com.google.android.MTCL83",
-            "com.google.android.UltraCVM",
-            "com.google.android.apps.cameralite",
-            "com.google.android.dialer",
-            "com.google.android.euicc",
-            "com.google.ar.core",
-            "com.google.android.youtube",
-            "com.google.android.apps.youtube.kids",
-            "com.google.android.apps.youtube.music",
-            "com.google.android.apps.recorder",
-            "com.google.android.apps.wearables.maestro.companion"
-    };
-
-    // Packages to Spoof as ROG Phone 1
-    private static final String[] packagesToChangeROG1 = {
-            "com.madfingergames.legends"
-    };
-
-    // Packages to Spoof as ROG Phone 3
-    private static final String[] packagesToChangeROG3 = {
-            "com.pearlabyss.blackdesertm",
-            "com.pearlabyss.blackdesertm.gl"
-    };
-
-    // Packages to Spoof as Xperia 5
-    private static final String[] packagesToChangeXP5 = {
-            "com.activision.callofduty.shooter",
-            "com.garena.game.codm",
-            "com.tencent.tmgp.kr.codm",
-            "com.vng.codmvn"
-    };
-
-    // Packages to Spoof as OnePlus 8 Pro
-    private static final String[] packagesToChangeOP8P = {
-            "com.netease.lztgglobal",
-            "com.pubg.imobile",
-            "com.pubg.krmobile",
-            "com.rekoo.pubgm",
-            "com.riotgames.league.wildrift",
-            "com.riotgames.league.wildrifttw",
-            "com.riotgames.league.wildriftvn",
-            "com.tencent.ig",
-            "com.tencent.tmgp.pubgmhd",
-            "com.vng.pubgmobile"
-    };
-
-    // Packages to Spoof as OnePlus 9R
-    private static final String[] packagesToChangeOP9R = {
-            "com.epicgames.fortnite",
-            "com.epicgames.portal"
-    };
-
-    // Packages to Spoof as Mi 11T
-    private static final String[] packagesToChange11T = {
-            "com.ea.gp.apexlegendsmobilefps",
-            "com.levelinfinite.hotta.gp",
-            "com.mobile.legends",
-            "com.supercell.clashofclans",
-            "com.tencent.tmgp.sgame",
-            "com.vng.mlbbvn"
-    };
-
-    // Packages to Spoof as POCO F4
-    private static final String[] packagesToChangeF4 = {
-            "com.dts.freefiremax",
-            "com.dts.freefireth"
-    };
-
-    // Codenames for currently supported Pixels by Google
-    private static final String[] pixelCodenames = {
-            "cheetah",
-            "panther",
-            "bluejay",
-            "oriole",
-            "raven",
-            "barbet",
-            "redfin",
-            "bramble",
-            "sunfish",
-            "coral",
-            "flame"
-    };
-
-    private static volatile boolean sIsGms = false;
-    private static volatile boolean sIsFinsky = false;
-
-    static {
-        propsToKeep = new HashMap<>();
-        propsToKeep.put("com.google.android.settings.intelligence", new ArrayList<>(Collections.singletonList("FINGERPRINT")));
-        propsToChangePixel7Pro = new HashMap<>();
-        propsToChangePixel7Pro.put("BRAND", "google");
-        propsToChangePixel7Pro.put("MANUFACTURER", "Google");
-        propsToChangePixel7Pro.put("DEVICE", "cheetah");
-        propsToChangePixel7Pro.put("PRODUCT", "cheetah");
-        propsToChangePixel7Pro.put("MODEL", "Pixel 7 Pro");
-        propsToChangePixel7Pro.put("FINGERPRINT", "google/cheetah/cheetah:13/TQ1A.230205.002/9471150:user/release-keys");
-        propsToChangePixel5 = new HashMap<>();
-        propsToChangePixel5.put("BRAND", "google");
-        propsToChangePixel5.put("MANUFACTURER", "Google");
-        propsToChangePixel5.put("DEVICE", "redfin");
-        propsToChangePixel5.put("PRODUCT", "redfin");
-        propsToChangePixel5.put("MODEL", "Pixel 5");
-        propsToChangePixel5.put("FINGERPRINT", "google/redfin/redfin:13/TQ1A.230205.002/9471150:user/release-keys");
-        propsToChangePixelXL = new HashMap<>();
-        propsToChangePixelXL.put("BRAND", "google");
-        propsToChangePixelXL.put("MANUFACTURER", "Google");
-        propsToChangePixelXL.put("DEVICE", "marlin");
-        propsToChangePixelXL.put("PRODUCT", "marlin");
-        propsToChangePixelXL.put("MODEL", "Pixel XL");
-        propsToChangePixelXL.put("FINGERPRINT", "google/marlin/marlin:10/QP1A.191005.007.A3/5972272:user/release-keys");
-        propsToChangeROG1 = new HashMap<>();
-        propsToChangeROG1.put("MODEL", "ASUS_Z01QD");
-        propsToChangeROG1.put("MANUFACTURER", "asus");
-        propsToChangeROG3 = new HashMap<>();
-        propsToChangeROG3.put("MODEL", "ASUS_I003D");
-        propsToChangeROG3.put("MANUFACTURER", "asus");
-        propsToChangeXP5 = new HashMap<>();
-        propsToChangeXP5.put("MODEL", "SO-52A");
-        propsToChangeXP5.put("MANUFACTURER", "Sony");
-        propsToChangeOP8P = new HashMap<>();
-        propsToChangeOP8P.put("MODEL", "IN2020");
-        propsToChangeOP8P.put("MANUFACTURER", "OnePlus");
-        propsToChangeOP9R = new HashMap<>();
-        propsToChangeOP9R.put("MODEL", "LE2101");
-        propsToChangeOP9R.put("MANUFACTURER", "OnePlus");
-        propsToChange11T = new HashMap<>();
-        propsToChange11T.put("MODEL", "21081111RG");
-        propsToChange11T.put("MANUFACTURER", "Xiaomi");
-        propsToChangeF4 = new HashMap<>();
-        propsToChangeF4.put("MODEL", "22021211RG");
-        propsToChangeF4.put("MANUFACTURER", "Xiaomi");
-    }
-
-    public static void setProps(String packageName) {
-        if (packageName == null || packageName.isEmpty()) {
-            return;
-        }
-        if (Arrays.asList(packagesToKeep).contains(packageName)) {
-            return;
-        }
-        if (packageName.startsWith("com.google.")
-                || Arrays.asList(extraPackagesToChange).contains(packageName)) {
-
-            Map<String, Object> propsToChange = new HashMap<>();
-            boolean isPixelDevice = Arrays.asList(pixelCodenames).contains(SystemProperties.get(DEVICE));
-
-            if (packageName.equals("com.google.android.apps.photos")) {
-                if (SystemProperties.getBoolean("persist.sys.pixelprops.gphotos", true)) {
-                    propsToChange.putAll(propsToChangePixelXL);
-                } else {
-                    if (isPixelDevice) return;
-                    propsToChange.putAll(propsToChangePixel5);
-                }
-            } else if (packageName.equals("com.netflix.mediaclient") && 
-                        !SystemProperties.getBoolean("persist.sys.pixelprops.netflix", false)) {
-                    if (DEBUG) Log.d(TAG, "Netflix spoofing disabled by system prop");
-                    return;
-            } else if (isPixelDevice) {
-                return;
-            } else if (packageName.equals("com.android.vending")) {
-                sIsFinsky = true;
-                return;
-            } else {
-                if (Arrays.asList(packagesToChangePixel7Pro).contains(packageName)) {
-                    propsToChange.putAll(propsToChangePixel7Pro);
-                } else if (Arrays.asList(packagesToChangePixelXL).contains(packageName)) {
-                    propsToChange.putAll(propsToChangePixelXL);
-                } else {
-                    propsToChange.putAll(propsToChangePixel5);
-                }
-            }
-
-            if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-            for (Map.Entry<String, Object> prop : propsToChange.entrySet()) {
-                String key = prop.getKey();
-                Object value = prop.getValue();
-                if (propsToKeep.containsKey(packageName) && propsToKeep.get(packageName).contains(key)) {
-                    if (DEBUG) Log.d(TAG, "Not defining " + key + " prop for: " + packageName);
-                    continue;
-                }
-                if (DEBUG) Log.d(TAG, "Defining " + key + " prop for: " + packageName);
-                setPropValue(key, value);
-            }
-            if (packageName.equals("com.google.android.gms")) {
-                final String processName = Application.getProcessName();
-                if (processName.equals("com.google.android.gms.unstable")) {
-                    sIsGms = true;
-                    spoofBuildGms();
-                }
-                return;
-            }
-            // Set proper indexing fingerprint
-            if (packageName.equals("com.google.android.settings.intelligence")) {
-                setPropValue("FINGERPRINT", Build.VERSION.INCREMENTAL);
-            }
-        } else {
-
-            if (!SystemProperties.getBoolean("persist.sys.pixelprops.games", false))
-                return;
-
-            if (Arrays.asList(packagesToChangeROG1).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeROG1.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeROG3).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeROG3.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeXP5).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeXP5.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeOP8P).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeOP8P.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeOP9R).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeOP9R.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChange11T).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChange11T.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            } else if (Arrays.asList(packagesToChangeF4).contains(packageName)) {
-                if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
-                for (Map.Entry<String, Object> prop : propsToChangeF4.entrySet()) {
-                    String key = prop.getKey();
-                    Object value = prop.getValue();
-                    setPropValue(key, value);
-                }
-            }
-        }
-    }
-
-    private static void setPropValue(String key, Object value) {
-        try {
-            if (DEBUG) Log.d(TAG, "Defining prop " + key + " to " + value.toString());
-            Field field = Build.class.getDeclaredField(key);
-            field.setAccessible(true);
-            field.set(null, value);
-            field.setAccessible(false);
-        } catch (NoSuchFieldException | IllegalAccessException e) {
-            Log.e(TAG, "Failed to set prop " + key, e);
-        }
-    }
-
-    private static void setBuildField(String key, String value) {
-        try {
-            // Unlock
-            Field field = Build.class.getDeclaredField(key);
-            field.setAccessible(true);
-
-            // Edit
-            field.set(null, value);
-
-            // Lock
-            field.setAccessible(false);
-        } catch (NoSuchFieldException | IllegalAccessException e) {
-            Log.e(TAG, "Failed to spoof Build." + key, e);
-        }
-    }
-
-    private static void setVersionField(String key, Integer value) {
-        try {
-            // Unlock
-            Field field = Build.VERSION.class.getDeclaredField(key);
-            field.setAccessible(true);
-
-            // Edit
-            field.set(null, value);
-
-            // Lock
-            field.setAccessible(false);
-        } catch (NoSuchFieldException | IllegalAccessException e) {
-            Log.e(TAG, "Failed to spoof Build." + key, e);
-        }
-    }
-
-    private static void spoofBuildGms() {
-        // Alter model name and fingerprint to avoid hardware attestation enforcement
-        setBuildField("FINGERPRINT", "google/marlin/marlin:7.1.2/NJH47F/4146041:user/release-keys");
-        setBuildField("PRODUCT", "marlin");
-        setBuildField("DEVICE", "marlin");
-        setBuildField("MODEL", "Pixel XL");
-        setVersionField("DEVICE_INITIAL_SDK_INT", Build.VERSION_CODES.N_MR1);
-    }
-
-    private static boolean isCallerSafetyNet() {
-        return sIsGms && Arrays.stream(Thread.currentThread().getStackTrace())
-                .anyMatch(elem -> elem.getClassName().contains("DroidGuard"));
-    }
-
-    public static void onEngineGetCertificateChain() {
-        // Check stack for SafetyNet or Play Integrity
-        if (isCallerSafetyNet() || sIsFinsky) {
-            Log.i(TAG, "Blocked key attestation sIsGms=" + sIsGms + " sIsFinsky=" + sIsFinsky);
-            throw new UnsupportedOperationException();
-        }
-    }
-}
diff --git a/core/res/res/values/cr_config.xml b/core/res/res/values/cr_config.xml
index 1762ec555f6c..34a55ed53e44 100644
--- a/core/res/res/values/cr_config.xml
+++ b/core/res/res/values/cr_config.xml
@@ -103,9 +103,6 @@
         <item>@string/face_unlock_disabled_idle</item>
     </string-array>
 
-    <!-- Enable face auth only when swiping security view -->
-    <bool name="config_faceAuthOnlyOnSecurityView">false</bool>
-
     <!-- Any package that has one of the package names defined below will be prevented
        from using specific sensors in order to stop battery drain -->
     <string-array name="config_blockPackagesSensorDrain">
diff --git a/core/res/res/values/cr_symbols.xml b/core/res/res/values/cr_symbols.xml
index 8fe2e1f1c09c..14b94d1a522e 100644
--- a/core/res/res/values/cr_symbols.xml
+++ b/core/res/res/values/cr_symbols.xml
@@ -101,9 +101,6 @@
     <!-- Whether to cancel fingerprint operation if not idle -->
     <java-symbol type="bool" name="config_fpCancelIfNotIdle" />
 
-    <!-- Enable face auth only when swiping security view -->
-    <java-symbol type="bool" name="config_faceAuthOnlyOnSecurityView" />
-
     <!-- Sensor block -->
     <java-symbol type="array" name="config_blockPackagesSensorDrain" />
 
diff --git a/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java b/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
index 82b6155f8c48..33411e1ec5b9 100644
--- a/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
+++ b/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
@@ -77,8 +77,6 @@ import java.util.Set;
 
 import javax.crypto.SecretKey;
 
-import com.android.internal.util.crdroid.PixelPropsUtils;
-
 /**
  * A java.security.KeyStore interface for the Android KeyStore. An instance of
  * it can be created via the {@link java.security.KeyStore#getInstance(String)
@@ -166,8 +164,6 @@ public class AndroidKeyStoreSpi extends KeyStoreSpi {
 
     @Override
     public Certificate[] engineGetCertificateChain(String alias) {
-        PixelPropsUtils.onEngineGetCertificateChain();
-
         KeyEntryResponse response = getKeyMetadata(alias);
 
         if (response == null || response.metadata.certificate == null) {
diff --git a/packages/SystemUI/Android.bp b/packages/SystemUI/Android.bp
index 81cae9dc1c15..ab1b3af5c521 100644
--- a/packages/SystemUI/Android.bp
+++ b/packages/SystemUI/Android.bp
@@ -128,7 +128,6 @@ android_library {
         "vendor.lineage.powershare-V1.0-java",
         "colorkt",
         "themelib",
-        "faceunlock_framework",
     ],
     manifest: "AndroidManifest.xml",
     additional_manifests: ["LineageManifest.xml"],
diff --git a/packages/SystemUI/res/values/cr_strings.xml b/packages/SystemUI/res/values/cr_strings.xml
index 900f702245b7..903f9319b324 100644
--- a/packages/SystemUI/res/values/cr_strings.xml
+++ b/packages/SystemUI/res/values/cr_strings.xml
@@ -157,9 +157,6 @@
     <string name="omnijaws_service_unknown">No weather data</string>
     <string name="omnijaws_label_default">Weather</string>
 
-    <!-- Face Unlock -->
-    <string name="face_unlock_recognizing">Recognizing face...</string>
-
     <!-- Refresh Rate Tile -->
     <string name="refresh_rate_tile_label">Refresh rate</string>
     <string name="auto_mode_label">Auto</string>
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
index 2cf73ee25e9a..739aa9892258 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
@@ -481,11 +481,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
 
     private static int sCurrentUser;
 
-    private final boolean mFaceAuthOnlyOnSecurityView;
-    public static final int FACE_UNLOCK_BEHAVIOR_DEFAULT = 0;
-    public static final int FACE_UNLOCK_BEHAVIOR_SWIPE = 1;
-    private int mFaceUnlockBehavior = FACE_UNLOCK_BEHAVIOR_DEFAULT;
-
     public synchronized static void setCurrentUser(int currentUser) {
         sCurrentUser = currentUser;
     }
@@ -897,9 +892,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
 
     private void handleFingerprintAuthenticated(int authUserId, boolean isStrongBiometric) {
         Trace.beginSection("KeyGuardUpdateMonitor#handlerFingerPrintAuthenticated");
-        if (mOccludingAppRequestingFace){
-            requestFaceAuthOnOccludingApp(false);
-        }
         if (mHandler.hasCallbacks(mFpCancelNotReceived)) {
             mLogger.d("handleFingerprintAuthenticated()"
                     + " triggered while waiting for cancellation, removing watchdog");
@@ -1124,9 +1116,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
 
     private void handleFaceAuthenticated(int authUserId, boolean isStrongBiometric) {
         Trace.beginSection("KeyGuardUpdateMonitor#handlerFaceAuthenticated");
-        if (mOccludingAppRequestingFace){
-            requestFaceAuthOnOccludingApp(false);
-        }
         try {
             if (mGoingToSleep) {
                 mLogger.d("Aborted successful auth because device is going to sleep.");
@@ -1310,9 +1299,9 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         final DevicePolicyManager dpm =
                 (DevicePolicyManager) mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
         // TODO(b/140035044)
-        return dpm != null && (dpm.getKeyguardDisabledFeatures(null, userId)
+        return whitelistIpcs(() -> dpm != null && (dpm.getKeyguardDisabledFeatures(null, userId)
                 & DevicePolicyManager.KEYGUARD_DISABLE_FACE) != 0
-                || isSimPinSecure();
+                || isSimPinSecure());
     }
 
     /**
@@ -1999,8 +1988,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         mTelephonyListenerManager = telephonyListenerManager;
         mDeviceProvisioned = isDeviceProvisionedInSettingsDb();
         mStrongAuthTracker = new StrongAuthTracker(context, this::notifyStrongAuthStateChanged);
-        mFaceAuthOnlyOnSecurityView = mContext.getResources().getBoolean(
-                com.android.internal.R.bool.config_faceAuthOnlyOnSecurityView);
         mBackgroundExecutor = backgroundExecutor;
         mBroadcastDispatcher = broadcastDispatcher;
         mInteractionJankMonitor = interactionJankMonitor;
@@ -2027,7 +2014,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
                 .collect(Collectors.toSet());
 
         updateFingerprintSettings();
-        updateFaceUnlockBehavior();
 
         mHandler = new Handler(mainLooper) {
             @Override
@@ -2290,15 +2276,11 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
             @Override
             public void onChange(boolean selfChange) {
                 updateFingerprintSettings();
-                updateFaceUnlockBehavior();
             }
         };
         mContext.getContentResolver().registerContentObserver(
                 LineageSettings.System.getUriFor(LineageSettings.System.FINGERPRINT_WAKE_UNLOCK),
                 false, mSettingsChangeObserver, UserHandle.USER_ALL);
-        mContext.getContentResolver().registerContentObserver(
-                Settings.Secure.getUriFor(Settings.Secure.FACE_UNLOCK_METHOD),
-                false, mSettingsChangeObserver, UserHandle.USER_ALL);
     }
 
     private void updateFingerprintSettings() {
@@ -2317,16 +2299,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         }
     }
 
-    private void updateFaceUnlockBehavior() {
-        if (mFaceAuthOnlyOnSecurityView) {
-            mFaceUnlockBehavior = FACE_UNLOCK_BEHAVIOR_SWIPE;
-        } else {
-            mFaceUnlockBehavior = Settings.Secure.getIntForUser(mContext.getContentResolver(),
-                Settings.Secure.FACE_UNLOCK_METHOD, FACE_UNLOCK_BEHAVIOR_DEFAULT,
-                UserHandle.USER_CURRENT);
-        }
-    }
-
     private void updateFaceEnrolled(int userId) {
         mIsFaceEnrolled = whitelistIpcs(
                 () -> mFaceManager != null && mFaceManager.isHardwareDetected()
@@ -2603,7 +2575,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
                 containsFlag(strongAuth, STRONG_AUTH_REQUIRED_AFTER_BOOT)
                         || containsFlag(strongAuth, STRONG_AUTH_REQUIRED_AFTER_TIMEOUT);
 
-        boolean shouldTriggerActiveUnlock =
+        final boolean shouldTriggerActiveUnlock =
                 (mAuthInterruptActive || triggerActiveUnlockForAssistant || awakeKeyguard)
                         && !mSwitchingUser
                         && !userCanDismissLockScreen
@@ -2614,10 +2586,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
                         && !mSecureCameraLaunched
                         && !mIsDeviceInPocket;
 
-        if (shouldTriggerActiveUnlock && mFaceUnlockBehavior == FACE_UNLOCK_BEHAVIOR_SWIPE && !mBouncerFullyShown) {
-            shouldTriggerActiveUnlock = false;
-        }
-
         // Aggregate relevant fields for debug logging.
         maybeLogListenerModelData(
                 new KeyguardActiveUnlockModel(
@@ -2832,10 +2800,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         return shouldListen;
     }
 
-    public int getFaceUnlockBehavior() {
-        return mFaceUnlockBehavior;
-    }
-
     private void maybeLogListenerModelData(KeyguardListenModel model) {
         mLogger.logKeyguardListenerModel(model);
 
@@ -2965,7 +2929,7 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         return mIsUnlockWithFingerprintPossible.getOrDefault(userId, false);
     }
 
-    public boolean isUnlockWithFacePossible(int userId) {
+    private boolean isUnlockWithFacePossible(int userId) {
         return isFaceAuthEnabledForUser(userId) && !isFaceDisabled(userId);
     }
 
@@ -3315,7 +3279,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         Assert.isMainThread();
         mLogger.logKeyguardVisibilityChanged(showing);
         mKeyguardIsVisible = showing;
-        mBouncerFullyShown = false;
 
         if (showing) {
             mSecureCameraLaunched = false;
@@ -3338,7 +3301,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         mLogger.d("handleKeyguardReset");
         updateBiometricListeningState(BIOMETRIC_ACTION_UPDATE,
                 FACE_AUTH_UPDATED_KEYGUARD_RESET);
-        mBouncerFullyShown = false;
         mNeedsSlowUnlockTransition = resolveNeedsSlowUnlockTransition();
     }
 
@@ -3409,15 +3371,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         }
     }
 
-    public void updateFaceListeningStateForBehavior(boolean fullyShow) {
-        if (mBouncerFullyShown != fullyShow){
-            mBouncerFullyShown = fullyShow;
-            if (mFaceUnlockBehavior == FACE_UNLOCK_BEHAVIOR_SWIPE){
-                updateFaceListeningState(BIOMETRIC_ACTION_UPDATE, FACE_AUTH_UPDATED_PRIMARY_BOUNCER_SHOWN);
-            }
-        }
-    }
-
     /**
      * Handle {@link #MSG_REQUIRE_NFC_UNLOCK}
      */
@@ -3448,7 +3401,6 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
      * Handle {@link #MSG_REPORT_EMERGENCY_CALL_ACTION}
      */
     private void handleReportEmergencyCallAction() {
-        mBouncerFullyShown = false;
         Assert.isMainThread();
         for (int i = 0; i < mCallbacks.size(); i++) {
             KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
diff --git a/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt b/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
index 57fe32f8f8d6..de34cd6b23ca 100644
--- a/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
+++ b/packages/SystemUI/src/com/android/systemui/privacy/AppOpsPrivacyItemMonitor.kt
@@ -53,9 +53,6 @@ class AppOpsPrivacyItemMonitor @Inject constructor(
 
     @VisibleForTesting
     companion object {
-        val CAMERA_WHITELIST_PKG = arrayOf(
-            "com.crdroid.faceunlock",
-        )
         val OPS_MIC_CAMERA = intArrayOf(AppOpsManager.OP_CAMERA,
                 AppOpsManager.OP_PHONE_CALL_CAMERA, AppOpsManager.OP_RECORD_AUDIO,
                 AppOpsManager.OP_PHONE_CALL_MICROPHONE,
@@ -88,8 +85,7 @@ class AppOpsPrivacyItemMonitor @Inject constructor(
         ) {
             synchronized(lock) {
                 // Check if we care about this code right now
-                if (code in OPS_MIC_CAMERA && !micCameraAvailable
-                        || packageName in CAMERA_WHITELIST_PKG) {
+                if (code in OPS_MIC_CAMERA && !micCameraAvailable) {
                     return
                 }
                 if (code in OPS_LOCATION && !locationAvailable) {
@@ -217,10 +213,6 @@ class AppOpsPrivacyItemMonitor @Inject constructor(
             AppOpsManager.OP_RECORD_AUDIO -> PrivacyType.TYPE_MICROPHONE
             else -> return null
         }
-        if (type == PrivacyType.TYPE_CAMERA && !micCameraAvailable
-                || appOpItem.packageName in CAMERA_WHITELIST_PKG) {
-            return null
-        }
         val app = PrivacyApplication(appOpItem.packageName, appOpItem.uid)
         return PrivacyItem(type, app, appOpItem.timeStartedElapsed, appOpItem.isDisabled)
     }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java b/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
index f25fd5c86d2d..ae1a7a83709c 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/KeyguardIndicationController.java
@@ -40,7 +40,6 @@ import static com.android.systemui.keyguard.KeyguardIndicationRotateTextViewCont
 import static com.android.systemui.keyguard.KeyguardIndicationRotateTextViewController.INDICATION_TYPE_USER_LOCKED;
 import static com.android.systemui.keyguard.ScreenLifecycle.SCREEN_ON;
 import static com.android.systemui.plugins.FalsingManager.LOW_PENALTY;
-import static com.android.keyguard.KeyguardUpdateMonitor.FACE_UNLOCK_BEHAVIOR_SWIPE;
 
 import android.app.admin.DevicePolicyManager;
 import android.content.BroadcastReceiver;
@@ -134,8 +133,6 @@ public class KeyguardIndicationController {
     private static final int MSG_SHOW_ACTION_TO_UNLOCK = 2;
     private static final int MSG_HIDE_BIOMETRIC_MESSAGE = 3;
     private static final int MSG_RESET_ERROR_MESSAGE_ON_SCREEN_ON = 4;
-    private static final int MSG_SHOW_RECOGNIZING_FACE = 5;
-    private static final int MSG_HIDE_RECOGNIZING_FACE = 6;
     private static final long TRANSIENT_BIOMETRIC_ERROR_TIMEOUT = 1300;
     public static final long DEFAULT_HIDE_DELAY_MS =
             3500 + KeyguardIndicationTextView.Y_IN_DURATION;
@@ -197,8 +194,6 @@ public class KeyguardIndicationController {
 
     private int mCurrentDivider;
 
-    private boolean mFaceDetectionRunning;
-
     private IBatteryPropertiesRegistrar mBatteryPropertiesRegistrar;
     private boolean mAlternateFastchargeInfoUpdate;
 
@@ -225,15 +220,6 @@ public class KeyguardIndicationController {
                 mBiometricErrorMessageToShowOnScreenOn = null;
             }
         }
-
-        @Override
-        public void onScreenTurnedOff() {
-            if (mFaceDetectionRunning) {
-                mFaceDetectionRunning = false;
-                mBiometricErrorMessageToShowOnScreenOn = null;
-                hideFaceUnlockRecognizingMessage();
-            }
-        }
     };
 
     /**
@@ -299,11 +285,6 @@ public class KeyguardIndicationController {
                     hideBiometricMessage();
                 } else if (msg.what == MSG_RESET_ERROR_MESSAGE_ON_SCREEN_ON) {
                     mBiometricErrorMessageToShowOnScreenOn = null;
-                } else if (msg.what == MSG_SHOW_RECOGNIZING_FACE) {
-                    mBiometricErrorMessageToShowOnScreenOn = null;
-                    showFaceUnlockRecognizingMessage();
-                } else if (msg.what == MSG_HIDE_RECOGNIZING_FACE) {
-                    hideFaceUnlockRecognizingMessage();
                 }
             }
         };
@@ -833,47 +814,6 @@ public class KeyguardIndicationController {
         }
     }
 
-    private void showFaceUnlockRecognizingMessage() {
-        if (mKeyguardUpdateMonitor.getFaceUnlockBehavior() == FACE_UNLOCK_BEHAVIOR_SWIPE){
-            return;
-        }
-
-        String faceUnlockMessage = mContext.getResources().getString(
-                                    R.string.face_unlock_recognizing);
-        mBiometricMessage = faceUnlockMessage;
-
-        mHandler.removeMessages(MSG_SHOW_ACTION_TO_UNLOCK);
-        mHandler.removeMessages(MSG_HIDE_BIOMETRIC_MESSAGE);
-
-        mRotateTextViewController.updateIndication(
-                INDICATION_TYPE_BIOMETRIC_MESSAGE,
-                new KeyguardIndication.Builder()
-                        .setMessage(mBiometricMessage)
-                        .setMinVisibilityMillis(6000L) // 6 seconds
-                        .setTextColor(mInitialTextColorState)
-                        .build(),
-                true
-        );
-
-        if (mDozing) {
-            updateDeviceEntryIndication(false);
-        }
-    }
-
-    private void hideFaceUnlockRecognizingMessage() {
-        if (mKeyguardUpdateMonitor.getFaceUnlockBehavior() == FACE_UNLOCK_BEHAVIOR_SWIPE){
-            return;
-        }
-
-        String faceUnlockMessage = mContext.getResources().getString(
-            R.string.face_unlock_recognizing);
-        if (mBiometricMessage != null && mBiometricMessage == faceUnlockMessage) {
-            mBiometricMessage = null;
-            mHandler.removeMessages(MSG_HIDE_BIOMETRIC_MESSAGE);
-            updateBiometricMessage();
-        }
-    }
-
     /**
      * Hides transient indication.
      */
@@ -1402,17 +1342,11 @@ public class KeyguardIndicationController {
         @Override
         public void onBiometricRunningStateChanged(boolean running,
                 BiometricSourceType biometricSourceType) {
-            if (biometricSourceType == BiometricSourceType.FACE) {
-                mFaceDetectionRunning = running;
-                if (running) {
-                    mHandler.removeMessages(MSG_HIDE_RECOGNIZING_FACE);
-                    mHandler.removeMessages(MSG_SHOW_RECOGNIZING_FACE);
-                    mHandler.sendEmptyMessageDelayed(MSG_SHOW_RECOGNIZING_FACE, 100);
-                } else {
-                    mHandler.removeMessages(MSG_SHOW_RECOGNIZING_FACE);
-                    mHandler.removeMessages(MSG_HIDE_RECOGNIZING_FACE);
-                    mHandler.sendEmptyMessageDelayed(MSG_HIDE_RECOGNIZING_FACE, 100);
-                }
+            if (running && biometricSourceType == FACE) {
+                // Let's hide any previous messages when authentication starts, otherwise
+                // multiple auth attempts would overlap.
+                hideBiometricMessage();
+                mBiometricErrorMessageToShowOnScreenOn = null;
             }
         }
 
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
index cc6cd1b59ce4..da6aca03b040 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBypassController.kt
@@ -94,8 +94,6 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
 
     var bypassEnabledBiometric: Boolean = false
 
-    var faceUnlockMethod: Int = 0
-
     var bouncerShowing: Boolean = false
     var altBouncerShowing: Boolean = false
     var launchingAffordance: Boolean = false
@@ -136,24 +134,13 @@ open class KeyguardBypassController : Dumpable, StackScrollAlgorithm.BypassContr
             }
         })
 
-        if (context.resources.getBoolean(
-                com.android.internal.R.bool.config_faceAuthOnlyOnSecurityView)){
-            bypassEnabledBiometric = false
-        }else{
-            tunerService.addTunable(object : TunerService.Tunable {
-                override fun onTuningChanged(key: String?, newValue: String?) {
-                    faceUnlockMethod = tunerService.getValue(key, 0)
-                }
-            }, Settings.Secure.FACE_UNLOCK_METHOD)
-            val dismissByDefault = if (context.resources.getBoolean(
-                            com.android.internal.R.bool.config_faceAuthDismissesKeyguard)) 1 else 0
-            tunerService.addTunable(object : TunerService.Tunable {
-                override fun onTuningChanged(key: String?, newValue: String?) {
-                    bypassEnabledBiometric = (faceUnlockMethod == 0 &&
-                        tunerService.getValue(key, dismissByDefault) != 0)
-                }
-            }, Settings.Secure.FACE_UNLOCK_DISMISSES_KEYGUARD)
-        }
+        val dismissByDefault = if (context.resources.getBoolean(
+                        com.android.internal.R.bool.config_faceAuthDismissesKeyguard)) 1 else 0
+        tunerService.addTunable(object : TunerService.Tunable {
+            override fun onTuningChanged(key: String?, newValue: String?) {
+                bypassEnabledBiometric = tunerService.getValue(key, dismissByDefault) != 0
+            }
+        }, Settings.Secure.FACE_UNLOCK_DISMISSES_KEYGUARD)
         lockscreenUserManager.addUserChangedListener(
                 object : NotificationLockscreenUserManager.UserChangedListener {
                     override fun onUserChanged(userId: Int) {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
index e324a403b35a..ec7b8204b864 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarKeyguardViewManager.java
@@ -29,7 +29,6 @@ import android.content.Context;
 import android.content.res.ColorStateList;
 import android.hardware.biometrics.BiometricSourceType;
 import android.os.Bundle;
-import android.os.Handler;
 import android.os.SystemClock;
 import android.os.Trace;
 import android.view.KeyEvent;
@@ -53,7 +52,6 @@ import com.android.keyguard.KeyguardUpdateMonitorCallback;
 import com.android.keyguard.KeyguardViewController;
 import com.android.keyguard.ViewMediatorCallback;
 import com.android.systemui.dagger.SysUISingleton;
-import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.dock.DockManager;
 import com.android.systemui.dreams.DreamOverlayStateController;
 import com.android.systemui.flags.FeatureFlags;
@@ -83,7 +81,6 @@ import com.android.systemui.statusbar.policy.ConfigurationController;
 import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.unfold.FoldAodAnimationController;
 import com.android.systemui.unfold.SysUIUnfoldComponent;
-import com.android.systemui.R;
 
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -138,7 +135,6 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
     private final BouncerViewDelegate mBouncerViewDelegate;
     private final Lazy<com.android.systemui.shade.ShadeController> mShadeController;
 
-    private boolean mBouncerVisible = false;
     private final BouncerExpansionCallback mExpansionCallback = new BouncerExpansionCallback() {
         private boolean mBouncerAnimating;
 
@@ -146,7 +142,6 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
         public void onFullyShown() {
             mBouncerAnimating = false;
             updateStates();
-            showFaceRecognizingMessage();
         }
 
         @Override
@@ -183,7 +178,6 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
                     .setBouncerShowingOverDream(
                             isVisible && mDreamOverlayStateController.isOverlayActive());
 
-            mBouncerVisible = isVisible;
             if (!isVisible) {
                 mCentralSurfaces.setBouncerHiddenFraction(KeyguardBouncer.EXPANSION_HIDDEN);
             }
@@ -258,10 +252,6 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
     private KeyguardBypassController mBypassController;
     @Nullable private AlternateAuthInterceptor mAlternateAuthInterceptor;
 
-    private Handler mHandler;
-    private Handler mFaceRecognizingHandler;
-    private boolean mFaceRecognitionRunning = false;
-
     private final KeyguardUpdateMonitorCallback mUpdateMonitorCallback =
             new KeyguardUpdateMonitorCallback() {
         @Override
@@ -273,28 +263,6 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
                 reset(true /* hideBouncerWhenShowing */);
             }
         }
-
-        @Override
-        public void onBiometricRunningStateChanged(boolean running,
-                BiometricSourceType biometricSourceType) {
-            if (biometricSourceType == BiometricSourceType.FACE &&
-                    mKeyguardUpdateManager.isUnlockWithFacePossible(mKeyguardUpdateManager.getCurrentUser())){
-                mFaceRecognitionRunning = running;
-                if (!mFaceRecognitionRunning){
-                    mFaceRecognizingHandler.removeCallbacksAndMessages(null);
-                }else{
-                    mFaceRecognizingHandler.postDelayed(() -> showFaceRecognizingMessage(), 100);
-                }
-            }
-        }
-
-        @Override
-        public void onBiometricAuthenticated(int userId, BiometricSourceType biometricSourceType,
-                boolean isStrongBiometric) {
-            if (biometricSourceType == BiometricSourceType.FACE) {
-                hideFaceRecognizingMessage();
-            }
-        }
     };
 
     @Inject
@@ -320,9 +288,7 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
             FeatureFlags featureFlags,
             BouncerCallbackInteractor bouncerCallbackInteractor,
             BouncerInteractor bouncerInteractor,
-            BouncerView bouncerView,
-            @Main Handler handler,
-            @Main Handler faceRecognizingHandler) {
+            BouncerView bouncerView) {
         mContext = context;
         mViewMediatorCallback = callback;
         mLockPatternUtils = lockPatternUtils;
@@ -346,8 +312,6 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
         mFoldAodAnimationController = sysUIUnfoldComponent
                 .map(SysUIUnfoldComponent::getFoldAodAnimationController).orElse(null);
         mIsModernBouncerEnabled = featureFlags.isEnabled(Flags.MODERN_BOUNCER);
-        mHandler = handler;
-        mFaceRecognizingHandler = faceRecognizingHandler;
     }
 
     @Override
@@ -673,11 +637,6 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
             }
         }
         updateStates();
-        mHandler.postDelayed(() -> {
-            if (mBouncerVisible) {
-                mKeyguardUpdateManager.updateFaceListeningStateForBehavior(mBouncerVisible);
-            }
-        }, 100);
     }
 
     private boolean isWakeAndUnlocking() {
@@ -1342,17 +1301,6 @@ public class StatusBarKeyguardViewManager implements RemoteInputController.Callb
         }
     }
 
-    private void showFaceRecognizingMessage() {
-        if (mFaceRecognitionRunning &&
-                mKeyguardUpdateManager.isUnlockWithFacePossible(mKeyguardUpdateManager.getCurrentUser())) {
-            setKeyguardMessage(mContext.getString(R.string.face_unlock_recognizing), null);
-        }
-    }
-
-    private void hideFaceRecognizingMessage() {
-        setKeyguardMessage("", null);
-    }
-
     /** Display security message to relevant KeyguardMessageArea. */
     public void setKeyguardMessage(String message, ColorStateList colorState) {
         if (isShowingAlternateAuth()) {
diff --git a/services/core/Android.bp b/services/core/Android.bp
index cf208bb0527b..6bf3a24750b1 100644
--- a/services/core/Android.bp
+++ b/services/core/Android.bp
@@ -178,7 +178,6 @@ java_library_static {
         "overlayable_policy_aidl-java",
         "SurfaceFlingerProperties",
         "com.android.sysprop.watchdog",
-        "faceunlock_framework",
         "kotlin-stdlib",
         "kotlinx_coroutines_android",
         "kotlinx_coroutines",
diff --git a/services/core/java/com/android/server/biometrics/AuthSession.java b/services/core/java/com/android/server/biometrics/AuthSession.java
index 2af0af945d3c..41ca13f5d5f5 100644
--- a/services/core/java/com/android/server/biometrics/AuthSession.java
+++ b/services/core/java/com/android/server/biometrics/AuthSession.java
@@ -70,8 +70,6 @@ import java.util.List;
 import java.util.Random;
 import java.util.function.Function;
 
-import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
-
 /**
  * Class that defines the states of an authentication session invoked via
  * {@link android.hardware.biometrics.BiometricPrompt}, as well as all of the necessary
@@ -333,9 +331,6 @@ public final class AuthSession implements IBinder.DeathRecipient {
     }
 
     private boolean isConfirmationRequired(BiometricSensor sensor) {
-        if (sensor.modality == TYPE_FACE && FaceUnlockUtils.isFaceUnlockSupported()) {
-            return true;
-        }
         return sensor.confirmationSupported()
                 && (sensor.confirmationAlwaysRequired(mUserId)
                 || mPreAuthInfo.confirmationRequested);
diff --git a/services/core/java/com/android/server/biometrics/BiometricService.java b/services/core/java/com/android/server/biometrics/BiometricService.java
index 4805d97c34cd..4767969bd3ed 100644
--- a/services/core/java/com/android/server/biometrics/BiometricService.java
+++ b/services/core/java/com/android/server/biometrics/BiometricService.java
@@ -85,8 +85,6 @@ import java.util.Set;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Supplier;
 
-import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
-
 /**
  * System service that arbitrates the modality for BiometricPrompt to use.
  */
@@ -216,6 +214,10 @@ public class BiometricService extends SystemService {
         private static final boolean DEFAULT_APP_ENABLED = true;
         private static final boolean DEFAULT_ALWAYS_REQUIRE_CONFIRMATION = false;
 
+        // Some devices that shipped before S already have face-specific settings. Instead of
+        // migrating, which is complicated, let's just keep using the existing settings.
+        private final boolean mUseLegacyFaceOnlySettings;
+
         // Only used for legacy face-only devices
         private final Uri FACE_UNLOCK_KEYGUARD_ENABLED =
                 Settings.Secure.getUriFor(Settings.Secure.FACE_UNLOCK_KEYGUARD_ENABLED);
@@ -255,13 +257,18 @@ public class BiometricService extends SystemService {
             final boolean hasFace = context.getPackageManager()
                     .hasSystemFeature(PackageManager.FEATURE_FACE);
 
+            // Use the legacy setting on face-only devices that shipped on or before Q
+            mUseLegacyFaceOnlySettings =
+                    Build.VERSION.DEVICE_INITIAL_SDK_INT <= Build.VERSION_CODES.Q
+                    && hasFace && !hasFingerprint;
+
             updateContentObserver();
         }
 
         public void updateContentObserver() {
             mContentResolver.unregisterContentObserver(this);
 
-            if (FaceUnlockUtils.isFaceUnlockSupported()) {
+            if (mUseLegacyFaceOnlySettings) {
                 mContentResolver.registerContentObserver(FACE_UNLOCK_KEYGUARD_ENABLED,
                         false /* notifyForDescendants */,
                         this /* observer */,
@@ -331,7 +338,7 @@ public class BiometricService extends SystemService {
 
         public boolean getEnabledOnKeyguard(int userId) {
             if (!mBiometricEnabledOnKeyguard.containsKey(userId)) {
-                if (FaceUnlockUtils.isFaceUnlockSupported()) {
+                if (mUseLegacyFaceOnlySettings) {
                     onChange(true /* selfChange */, FACE_UNLOCK_KEYGUARD_ENABLED, userId);
                 } else {
                     onChange(true /* selfChange */, BIOMETRIC_KEYGUARD_ENABLED, userId);
@@ -342,7 +349,7 @@ public class BiometricService extends SystemService {
 
         public boolean getEnabledForApps(int userId) {
             if (!mBiometricEnabledForApps.containsKey(userId)) {
-                if (FaceUnlockUtils.isFaceUnlockSupported()) {
+                if (mUseLegacyFaceOnlySettings) {
                     onChange(true /* selfChange */, FACE_UNLOCK_APP_ENABLED, userId);
                 } else {
                     onChange(true /* selfChange */, BIOMETRIC_APP_ENABLED, userId);
@@ -1316,6 +1323,9 @@ public class BiometricService extends SystemService {
     }
 
     private void dumpInternal(PrintWriter pw) {
+        pw.println("Legacy Settings: " + mSettingObserver.mUseLegacyFaceOnlySettings);
+        pw.println();
+
         pw.println("Sensors:");
         for (BiometricSensor sensor : mSensors) {
             pw.println(" " + sensor);
diff --git a/services/core/java/com/android/server/biometrics/PreAuthInfo.java b/services/core/java/com/android/server/biometrics/PreAuthInfo.java
index b694746b69b7..aec98f0ea426 100644
--- a/services/core/java/com/android/server/biometrics/PreAuthInfo.java
+++ b/services/core/java/com/android/server/biometrics/PreAuthInfo.java
@@ -42,8 +42,6 @@ import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 
-import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
-
 /**
  * Class representing the calling client's request. Additionally, derives/calculates
  * preliminary info that would be useful in helping serve this request. Note that generating
@@ -229,9 +227,6 @@ class PreAuthInfo {
 
     private static boolean isEnabledForApp(BiometricService.SettingObserver settingObserver,
             @BiometricAuthenticator.Modality int modality, int userId) {
-        if (modality == TYPE_FINGERPRINT && FaceUnlockUtils.isFaceUnlockSupported()){
-            return true;
-        }
         return settingObserver.getEnabledForApps(userId);
     }
 
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java b/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
index ccbd10c8e8e3..2e820574b435 100644
--- a/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
+++ b/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
@@ -25,7 +25,6 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.content.Context;
 import android.hardware.biometrics.BiometricManager;
-import android.hardware.biometrics.SensorProperties;
 import android.hardware.biometrics.BiometricsProtoEnums;
 import android.hardware.biometrics.IBiometricSensorReceiver;
 import android.hardware.biometrics.IBiometricService;
@@ -63,7 +62,6 @@ import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
 import com.android.server.biometrics.sensors.LockoutResetDispatcher;
 import com.android.server.biometrics.sensors.LockoutTracker;
 import com.android.server.biometrics.sensors.face.aidl.FaceProvider;
-import com.android.server.biometrics.sensors.face.custom.CustomFaceProvider;
 import com.android.server.biometrics.sensors.face.hidl.Face10;
 
 import java.io.FileDescriptor;
@@ -656,12 +654,6 @@ public class FaceService extends SystemService {
             }
         }
 
-        private void addCustomProviders() {
-            if (CustomFaceProvider.useCustomFaceUnlockService()) {
-                mServiceProviders.add(new CustomFaceProvider(getContext(), new FaceSensorPropertiesInternal(CustomFaceProvider.DEVICE_ID, SensorProperties.STRENGTH_WEAK, 1, new ArrayList(), 1, false, false, false), mLockoutResetDispatcher));
-            }
-        }
-
         @Override // Binder call
         public void registerAuthenticators(
                 @NonNull List<FaceSensorPropertiesInternal> hidlSensors) {
@@ -679,7 +671,6 @@ public class FaceService extends SystemService {
             handler.post(() -> {
                 addHidlProviders(hidlSensors);
                 addAidlProviders();
-                addCustomProviders();
 
                 final IBiometricService biometricService = IBiometricService.Stub.asInterface(
                         ServiceManager.getService(Context.BIOMETRIC_SERVICE));
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java
deleted file mode 100644
index 617781c0a08f..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import java.util.ArrayList;
-
-public class ArrayUtils {
-    public static ArrayList<Byte> toByteArrayList(byte[] in) {
-        if (in == null) {
-            return null;
-        }
-        ArrayList<Byte> out = new ArrayList<>(in.length);
-        for (byte c : in) {
-            out.add(c);
-        }
-        return out;
-    }
-
-    public static ArrayList<Integer> toIntArrayList(int[] in) {
-        if (in == null) {
-            return null;
-        }
-        ArrayList<Integer> out = new ArrayList<>(in.length);
-        for (int c : in) {
-            out.add(c);
-        }
-        return out;
-    }
-
-    public static int[] toIntArray(ArrayList<Integer> in) {
-        if (in == null) {
-            return null;
-        }
-        int[] out = new int[in.size()];
-        for (int i = 0; i < in.size(); i++) {
-            out[i] = in.get(i);
-        }
-        return out;
-    }
-
-    public static byte[] toByteArray(ArrayList<Byte> in) {
-        if (in == null) {
-            return null;
-        }
-        byte[] out = new byte[in.size()];
-        for (int i = 0; i < in.size(); i++) {
-            out[i] = in.get(i);
-        }
-        return out;
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java
deleted file mode 100644
index 83e772b0e20b..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.hardware.biometrics.ITestSession;
-import android.hardware.biometrics.ITestSessionCallback;
-import android.hardware.face.Face;
-import android.hardware.face.FaceAuthenticationFrame;
-import android.hardware.face.FaceEnrollFrame;
-import android.hardware.face.IFaceServiceReceiver;
-import android.os.Binder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.server.biometrics.Utils;
-import com.android.server.biometrics.sensors.BaseClientMonitor;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.face.FaceUtils;
-
-import java.util.List;
-import java.util.Random;
-
-public class BiometricTestSessionImpl extends ITestSession.Stub {
-    private static final String TAG = "BiometricTestSessionImpl";
-    private final ITestSessionCallback mCallback;
-    private final Context mContext;
-    private final CustomFaceProvider.HalResultController mHalResultController;
-    private final CustomFaceProvider mCustomFaceProvider;
-    private final int mSensorId;
-    private final IFaceServiceReceiver mReceiver = new IFaceServiceReceiver.Stub() {
-        @Override
-        public void onEnrollResult(Face face, int remaining) {
-        }
-
-        @Override
-        public void onAcquired(int acquiredInfo, int vendorCode) {
-        }
-
-        @Override
-        public void onAuthenticationSucceeded(Face face, int userId, boolean isStrongBiometric) {
-        }
-
-        @Override
-        public void onFaceDetected(int sensorId, int userId, boolean isStrongBiometric) {
-        }
-
-        @Override
-        public void onAuthenticationFailed() {
-        }
-
-        @Override
-        public void onError(int error, int vendorCode) {
-        }
-
-        @Override
-        public void onRemoved(Face face, int remaining) {
-        }
-
-        @Override
-        public void onFeatureSet(boolean success, int feature) {
-        }
-
-        @Override
-        public void onFeatureGet(boolean success, int[] features, boolean[] featureState) {
-        }
-
-        public void onChallengeGenerated(int sensorId, int userId, long challenge) {
-        }
-
-        @Override
-        public void onAuthenticationFrame(FaceAuthenticationFrame frame) {
-        }
-
-        @Override
-        public void onEnrollmentFrame(FaceEnrollFrame frame) {
-        }
-    };
-    private final Random mRandom = new Random();
-
-    public BiometricTestSessionImpl(Context context, int sensorId, ITestSessionCallback callback, CustomFaceProvider customFaceProvider, CustomFaceProvider.HalResultController halResultController) {
-        mContext = context;
-        mSensorId = sensorId;
-        mCallback = callback;
-        mCustomFaceProvider = customFaceProvider;
-        mHalResultController = halResultController;
-    }
-
-    public void setTestHalEnabled(boolean enabled) {
-        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
-        mCustomFaceProvider.setTestHalEnabled(enabled);
-    }
-
-    public void startEnroll(int userId) {
-        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
-        mCustomFaceProvider.scheduleEnroll(mSensorId, new Binder(), new byte[69], userId, mReceiver, mContext.getOpPackageName(), new int[0], null, false);
-    }
-
-    public void finishEnroll(int userId) {
-        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
-        mHalResultController.onEnrollResult(1, userId, 0);
-    }
-
-    public void acceptAuthentication(int userId) {
-        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
-        List<Face> faces = FaceUtils.getLegacyInstance(mSensorId).getBiometricsForUser(mContext, userId);
-        if (faces.isEmpty()) {
-            Slog.w(TAG, "No faces, returning");
-        } else {
-            mHalResultController.onAuthenticated(faces.get(0).getBiometricId(), userId, new byte[]{0});
-        }
-    }
-
-    public void rejectAuthentication(int userId) {
-        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
-        mHalResultController.onAuthenticated(0, userId, null);
-    }
-
-    public void notifyAcquired(int userId, int acquireInfo) {
-        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
-        mHalResultController.onAcquired(userId, acquireInfo, 0);
-    }
-
-    public void notifyError(int userId, int errorCode) {
-        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
-        mHalResultController.onError(errorCode, 0);
-    }
-
-    public void cleanupInternalState(int userId) {
-        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
-        mCustomFaceProvider.scheduleInternalCleanup(mSensorId, userId, new ClientMonitorCallback() {
-            @Override
-            public void onClientStarted(BaseClientMonitor clientMonitor) {
-                try {
-                    mCallback.onCleanupStarted(clientMonitor.getTargetUserId());
-                } catch (RemoteException e) {
-                    Slog.e(BiometricTestSessionImpl.TAG, "Remote exception", e);
-                }
-            }
-
-            @Override
-            public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
-                try {
-                    mCallback.onCleanupFinished(clientMonitor.getTargetUserId());
-                } catch (RemoteException e) {
-                    Slog.e(BiometricTestSessionImpl.TAG, "Remote exception", e);
-                }
-            }
-        });
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java
deleted file mode 100644
index 0b0119970c06..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java
+++ /dev/null
@@ -1,848 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.app.ActivityManager;
-import android.app.SynchronousUserSwitchObserver;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.ServiceConnection;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.content.pm.UserInfo;
-import android.hardware.biometrics.BiometricsProtoEnums;
-import android.hardware.biometrics.IInvalidationCallback;
-import android.hardware.biometrics.ITestSession;
-import android.hardware.biometrics.ITestSessionCallback;
-import android.hardware.face.Face;
-import android.hardware.face.FaceSensorPropertiesInternal;
-import android.hardware.face.IFaceServiceReceiver;
-import android.os.Binder;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.RemoteException;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.provider.Settings;
-import android.util.Slog;
-import android.util.SparseArray;
-import android.util.proto.ProtoOutputStream;
-import android.view.Surface;
-
-import android.annotation.NonNull;
-
-import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.SensorServiceStateProto;
-import com.android.server.biometrics.SensorStateProto;
-import com.android.server.biometrics.UserStateProto;
-import com.android.server.biometrics.Utils;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-import com.android.server.biometrics.sensors.AcquisitionClient;
-import com.android.server.biometrics.sensors.AuthenticationConsumer;
-import com.android.server.biometrics.sensors.BaseClientMonitor;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.BiometricNotificationUtils;
-import com.android.server.biometrics.sensors.BiometricScheduler;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.EnumerateConsumer;
-import com.android.server.biometrics.sensors.ErrorConsumer;
-import com.android.server.biometrics.sensors.LockoutResetDispatcher;
-import com.android.server.biometrics.sensors.PerformanceTracker;
-import com.android.server.biometrics.sensors.RemovalConsumer;
-import com.android.server.biometrics.sensors.face.FaceUtils;
-import com.android.server.biometrics.sensors.face.LockoutHalImpl;
-import com.android.server.biometrics.sensors.face.ServiceProvider;
-import com.android.server.biometrics.sensors.face.UsageStats;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.FileDescriptor;
-import java.io.PrintWriter;
-import java.time.Clock;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.function.Supplier;
-
-public class CustomFaceProvider implements ServiceProvider {
-    public static final int DEVICE_ID = 1008;
-    private static final int ENROLL_TIMEOUT_SEC = 75;
-    private static final int GENERATE_CHALLENGE_COUNTER_TTL_MILLIS = 600000;
-    private static final int GENERATE_CHALLENGE_REUSE_INTERVAL_MILLIS = 60000;
-    private static final String TAG = CustomFaceProvider.class.getSimpleName();
-    public static Clock sSystemClock = Clock.systemUTC();
-    final SparseArray<IFaceService> mFaceServices;
-    private final Map<Integer, Long> mAuthenticatorIds;
-    private final Context mContext;
-    private final List<Long> mGeneratedChallengeCount;
-    private final HalResultController mHalResultController;
-    private final Handler mHandler;
-    private final Supplier<IFaceService> mLazyDaemon;
-    private final LockoutHalImpl mLockoutTracker;
-    private final BiometricScheduler mScheduler;
-    private final int mSensorId;
-    private final FaceSensorPropertiesInternal mSensorProperties;
-    private final UsageStats mUsageStats;
-    @NonNull
-    private final AtomicLong mRequestCounter = new AtomicLong(0);
-    private int mCurrentUserId;
-    private FaceGenerateChallengeClient mGeneratedChallengeCache;
-    private boolean mIsServiceBinding;
-    private TestHal mTestHal;
-    private boolean mTestHalEnabled;
-
-    private BiometricContext mBiometricContext;
-
-    CustomFaceProvider(Context context, FaceSensorPropertiesInternal sensorProps, LockoutResetDispatcher lockoutResetDispatcher, BiometricScheduler scheduler) {
-        mBiometricContext = BiometricContext.getInstance(context);
-        mTestHalEnabled = false;
-        mCurrentUserId = -10000;
-        mGeneratedChallengeCount = new ArrayList<>();
-        mGeneratedChallengeCache = null;
-        mFaceServices = new SparseArray<>();
-        mIsServiceBinding = false;
-        mSensorProperties = sensorProps;
-        mContext = context;
-        mSensorId = sensorProps.sensorId;
-        mScheduler = scheduler;
-        Handler handler = new Handler(Looper.getMainLooper());
-        mHandler = handler;
-        mUsageStats = new UsageStats(context);
-        mAuthenticatorIds = new HashMap<>();
-        mLazyDaemon = CustomFaceProvider.this::getDaemon;
-        LockoutHalImpl lockoutHalImpl = new LockoutHalImpl();
-        mLockoutTracker = lockoutHalImpl;
-        HalResultController halResultController = new HalResultController(sensorProps.sensorId, context, handler, scheduler, lockoutHalImpl, lockoutResetDispatcher);
-        mHalResultController = halResultController;
-        halResultController.setCallback(() -> {
-            mCurrentUserId = -10000;
-        });
-        mCurrentUserId = ActivityManager.getCurrentUser();
-        try {
-            ActivityManager.getService().registerUserSwitchObserver(new SynchronousUserSwitchObserver() {
-                public void onUserSwitching(int newUserId) {
-                    Slog.d(TAG, "user switch : newUserId = " + newUserId);
-                    mCurrentUserId = newUserId;
-                    if (getDaemon() == null) {
-                        bindFaceAuthService(mCurrentUserId);
-                    }
-                }
-            }, TAG);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to register user switch observer");
-        }
-        context.registerReceiver(new BroadcastReceiver() {
-            @Override
-            public void onReceive(Context context2, Intent intent) {
-                if (getDaemon() == null) {
-                    bindFaceAuthService(mCurrentUserId);
-                }
-            }
-        }, new IntentFilter("android.intent.action.USER_UNLOCKED"));
-    }
-
-    public CustomFaceProvider(Context context, FaceSensorPropertiesInternal sensorProps, LockoutResetDispatcher lockoutResetDispatcher) {
-        this(context, sensorProps, lockoutResetDispatcher, new BiometricScheduler(context, TAG, 0, null));
-    }
-
-    synchronized IFaceService getDaemon() {
-        if (mTestHalEnabled) {
-            if (mTestHal == null) {
-                mTestHal = new TestHal(mCurrentUserId, mContext, mSensorId);
-            }
-            try {
-                mTestHal.setCallback(mHalResultController);
-            } catch (RemoteException e) {
-                e.printStackTrace();
-            }
-            return mTestHal;
-        }
-        IFaceService service = getFaceService(mCurrentUserId);
-        if (service == null) {
-            bindFaceAuthService(mCurrentUserId);
-        }
-        return service;
-    }
-
-    @Override
-    public boolean containsSensor(int sensorId) {
-        return mSensorId == sensorId;
-    }
-
-    @Override
-    public List<FaceSensorPropertiesInternal> getSensorProperties() {
-        List<FaceSensorPropertiesInternal> properties = new ArrayList<>();
-        properties.add(mSensorProperties);
-        return properties;
-    }
-
-    @Override
-    public FaceSensorPropertiesInternal getSensorProperties(int sensorId) {
-        return mSensorProperties;
-    }
-
-    @Override
-    public List<Face> getEnrolledFaces(int sensorId, int userId) {
-        return FaceUtils.getLegacyInstance(mSensorId).getBiometricsForUser(mContext, userId);
-    }
-
-    @Override
-    public int getLockoutModeForUser(int sensorId, int userId) {
-        return mLockoutTracker.getLockoutModeForUser(userId);
-    }
-
-    @Override
-    public long getAuthenticatorId(int sensorId, int userId) {
-        return mAuthenticatorIds.getOrDefault(Integer.valueOf(userId), 0L).longValue();
-    }
-
-    @Override
-    public boolean isHardwareDetected(int sensorId) {
-        return getDaemon() != null;
-    }
-
-    private boolean isGeneratedChallengeCacheValid() {
-        return mGeneratedChallengeCache != null && sSystemClock.millis() - mGeneratedChallengeCache.getCreatedAt() < GENERATE_CHALLENGE_REUSE_INTERVAL_MILLIS;
-    }
-
-    private void incrementChallengeCount() {
-        mGeneratedChallengeCount.add(0, sSystemClock.millis());
-    }
-
-    private int decrementChallengeCount() {
-        mGeneratedChallengeCount.removeIf(aLong -> sSystemClock.millis() - aLong > GENERATE_CHALLENGE_COUNTER_TTL_MILLIS);
-        if (!mGeneratedChallengeCount.isEmpty()) {
-            mGeneratedChallengeCount.remove(0);
-        }
-        return mGeneratedChallengeCount.size();
-    }
-
-    @Override
-    public void scheduleGenerateChallenge(int sensorId, int userId, IBinder token, IFaceServiceReceiver receiver, String opPackageName) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindFaceAuthService(mCurrentUserId);
-                try {
-                    receiver.onChallengeGenerated(sensorId, userId, 0);
-                } catch (RemoteException e) {
-                    e.printStackTrace();
-                }
-            } else {
-                incrementChallengeCount();
-                if (isGeneratedChallengeCacheValid()) {
-                    Slog.d(TAG, "Current challenge is cached and will be reused");
-                    mGeneratedChallengeCache.reuseResult(receiver);
-                    return;
-                }
-                scheduleUpdateActiveUserWithoutHandler(userId);
-                final FaceGenerateChallengeClient client = new FaceGenerateChallengeClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, opPackageName, mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, sSystemClock.millis());
-                mGeneratedChallengeCache = client;
-                mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
-                    @Override
-                    public void onClientStarted(BaseClientMonitor clientMonitor) {
-                        if (client != clientMonitor) {
-                            Slog.e(TAG, "scheduleGenerateChallenge onClientStarted, mismatched client. Expecting: " + client + ", received: " + clientMonitor);
-                        }
-                    }
-                });
-            }
-        });
-    }
-
-    @Override
-    public void scheduleRevokeChallenge(int sensorId, int userId, IBinder token, String opPackageName, long challenge) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindFaceAuthService(mCurrentUserId);
-                return;
-            }
-            if (!(decrementChallengeCount() == 0)) {
-                Slog.w(TAG, "scheduleRevokeChallenge skipped - challenge still in use: " + mGeneratedChallengeCount);
-                return;
-            }
-            Slog.d(TAG, "scheduleRevokeChallenge executing - no active clients");
-            mGeneratedChallengeCache = null;
-            final FaceRevokeChallengeClient client = new FaceRevokeChallengeClient(mContext, mLazyDaemon, token, userId, opPackageName, mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext);
-            mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
-                @Override
-                public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
-                    if (client != clientMonitor) {
-                        Slog.e(TAG, "scheduleRevokeChallenge, mismatched client.Expecting: " + client + ", received: " + clientMonitor);
-                    }
-                }
-            });
-        });
-    }
-
-    @Override
-    public long scheduleEnroll(int sensorId, IBinder token, byte[] hardwareAuthToken, int userId, IFaceServiceReceiver receiver, String opPackageName, int[] disabledFeatures, Surface previewSurface, boolean debugConsent) {
-        final long id = mRequestCounter.incrementAndGet();
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindFaceAuthService(mCurrentUserId);
-                try {
-                    receiver.onError(2, 0);
-                } catch (RemoteException e) {
-                    e.printStackTrace();
-                }
-            } else {
-                scheduleUpdateActiveUserWithoutHandler(userId);
-                BiometricNotificationUtils.cancelReEnrollNotification(mContext);
-                final FaceEnrollClient client = new FaceEnrollClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, hardwareAuthToken, opPackageName, FaceUtils.getLegacyInstance(mSensorId), disabledFeatures, ENROLL_TIMEOUT_SEC, previewSurface, mSensorId, createLogger(BiometricsProtoEnums.ACTION_ENROLL, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext);
-                mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
-                    @Override
-                    public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
-                        if (success) {
-                            scheduleUpdateActiveUserWithoutHandler(client.getTargetUserId());
-                        }
-                    }
-                });
-            }
-        });
-        return id;
-    }
-
-    @Override
-    public void cancelEnrollment(int sensorId, IBinder token, long requestId) {
-        mHandler.post(() -> mScheduler.cancelEnrollment(token, requestId));
-    }
-
-    @Override
-    public long scheduleFaceDetect(int sensorId, IBinder token, int userId, ClientMonitorCallbackConverter callback, String opPackageName, int statsClient) {
-        throw new IllegalStateException("Face detect not supported by IBiometricsFace@1.0. Did youforget to check the supportsFaceDetection flag?");
-    }
-
-    @Override
-    public void cancelFaceDetect(int sensorId, IBinder token, long requestId) {
-        throw new IllegalStateException("Face detect not supported by IBiometricsFace@1.0. Did youforget to check the supportsFaceDetection flag?");
-    }
-
-    @Override
-    public long scheduleAuthenticate(int sensorId, IBinder token, long operationId,
-                                     int userId, int cookie, ClientMonitorCallbackConverter receiver,
-                                     String opPackageName, boolean restricted, int statsClient,
-                                     boolean allowBackgroundAuthentication, boolean isKeyguardBypassEnabled) {
-        final long id = mRequestCounter.incrementAndGet();
-        scheduleAuthenticate(sensorId, token, operationId, userId, cookie, receiver,
-                opPackageName, id, restricted, statsClient,
-                allowBackgroundAuthentication, isKeyguardBypassEnabled);
-        return id;
-    }
-
-    @Override
-    public void scheduleAuthenticate(int sensorId, IBinder token, long operationId, int userId, int cookie, ClientMonitorCallbackConverter receiver, String opPackageName, long requestId, boolean restricted, int statsClient, boolean allowBackgroundAuthentication, boolean isKeyguardBypassEnabled) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindFaceAuthService(mCurrentUserId);
-                try {
-                    receiver.onError(DEVICE_ID, 0, 1, 0);
-                } catch (RemoteException e) {
-                    e.printStackTrace();
-                }
-            } else {
-                scheduleUpdateActiveUserWithoutHandler(userId);
-                mScheduler.scheduleClientMonitor(new FaceAuthenticationClient(mContext, mLazyDaemon, token, requestId, receiver, userId, operationId, restricted, opPackageName, cookie, false, mSensorId, createLogger(BiometricsProtoEnums.ACTION_AUTHENTICATE, statsClient), mBiometricContext, Utils.isStrongBiometric(mSensorId), mLockoutTracker, mUsageStats, allowBackgroundAuthentication));
-            }
-        });
-    }
-
-    @Override
-    public void cancelAuthentication(int sensorId, IBinder token, long requestId) {
-        mHandler.post(() -> mScheduler.cancelAuthenticationOrDetection(token, requestId));
-    }
-
-    @Override
-    public void scheduleRemove(int sensorId, IBinder token, int faceId, int userId, IFaceServiceReceiver receiver, String opPackageName) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindFaceAuthService(mCurrentUserId);
-                try {
-                    receiver.onError(1, 0);
-                } catch (RemoteException e) {
-                    e.printStackTrace();
-                }
-            } else {
-                scheduleUpdateActiveUserWithoutHandler(userId);
-                mScheduler.scheduleClientMonitor(new FaceRemovalClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), faceId, userId, opPackageName, FaceUtils.getLegacyInstance(mSensorId), mSensorId, createLogger(BiometricsProtoEnums.ACTION_REMOVE, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, mAuthenticatorIds));
-            }
-        });
-    }
-
-    @Override
-    public void scheduleRemoveAll(int sensorId, IBinder token, int userId, IFaceServiceReceiver receiver, String opPackageName) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindFaceAuthService(mCurrentUserId);
-                try {
-                    receiver.onError(1, 0);
-                } catch (RemoteException e) {
-                    e.printStackTrace();
-                }
-            } else {
-                scheduleUpdateActiveUserWithoutHandler(userId);
-                mScheduler.scheduleClientMonitor(new FaceRemovalClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), 0, userId, opPackageName, FaceUtils.getLegacyInstance(mSensorId), mSensorId, createLogger(BiometricsProtoEnums.ACTION_REMOVE, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, mAuthenticatorIds));
-            }
-        });
-    }
-
-    @Override
-    public void scheduleResetLockout(int sensorId, int userId, byte[] hardwareAuthToken) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindFaceAuthService(mCurrentUserId);
-            } else if (getEnrolledFaces(sensorId, userId).isEmpty()) {
-                Slog.w(TAG, "Ignoring lockout reset, no templates enrolled for user: " + userId);
-            } else {
-                scheduleUpdateActiveUserWithoutHandler(userId);
-                mScheduler.scheduleClientMonitor(new FaceResetLockoutClient(mContext, mLazyDaemon, userId, mContext.getOpPackageName(), mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, hardwareAuthToken));
-            }
-        });
-    }
-
-    @Override
-    public void scheduleSetFeature(int sensorId, IBinder token, int userId, int feature, boolean enabled, byte[] hardwareAuthToken, IFaceServiceReceiver receiver, String opPackageName) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindFaceAuthService(mCurrentUserId);
-                return;
-            }
-            List<Face> faces = getEnrolledFaces(sensorId, userId);
-            if (faces.isEmpty()) {
-                Slog.w(TAG, "Ignoring setFeature, no templates enrolled for user: " + userId);
-                return;
-            }
-            scheduleUpdateActiveUserWithoutHandler(userId);
-            mScheduler.scheduleClientMonitor(new FaceSetFeatureClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, opPackageName, mSensorId, BiometricLogger.ofUnknown(mContext), mBiometricContext, feature, enabled, hardwareAuthToken, faces.get(0).getBiometricId()));
-        });
-    }
-
-    @Override
-    public void scheduleGetFeature(int sensorId, IBinder token, int userId, int feature, ClientMonitorCallbackConverter listener, String opPackageName) {
-        mHandler.post(() -> {
-            if (getDaemon() == null) {
-                bindFaceAuthService(mCurrentUserId);
-                if (listener != null) {
-                    try {
-                        listener.onError(DEVICE_ID, 0, 1, 0);
-                    } catch (RemoteException e) {
-                        e.printStackTrace();
-                    }
-                }
-            } else {
-                List<Face> faces = getEnrolledFaces(sensorId, userId);
-                if (faces.isEmpty()) {
-                    Slog.w(TAG, "Ignoring getFeature, no templates enrolled for user: " + userId);
-                    return;
-                }
-                scheduleUpdateActiveUserWithoutHandler(userId);
-                final FaceGetFeatureClient client = new FaceGetFeatureClient(mContext, mLazyDaemon, token, listener, userId, opPackageName, mSensorId, BiometricLogger.ofUnknown(mContext), mBiometricContext, feature, faces.get(0).getBiometricId());
-                mScheduler.scheduleClientMonitor(client, new ClientMonitorCallback() {
-                    @Override
-                    public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
-                        if (success && feature == 1) {
-                            final int settingsValue = client.getValue() ? 1 : 0;
-                            Slog.d(TAG, "Updating attention value for user: " + userId + " to value: " + settingsValue);
-                            Settings.Secure.putIntForUser(mContext.getContentResolver(), "face_unlock_attention_required", settingsValue, userId);
-                        }
-                    }
-                });
-            }
-        });
-    }
-
-    void scheduleInternalCleanup(int userId, ClientMonitorCallback callback) {
-        mHandler.post(() -> {
-            scheduleUpdateActiveUserWithoutHandler(userId);
-            List<Face> enrolledList = getEnrolledFaces(mSensorId, userId);
-            String opPackageName = mContext.getOpPackageName();
-            mScheduler.scheduleClientMonitor(new FaceInternalCleanupClient(mContext, mLazyDaemon, userId, opPackageName, mSensorId, createLogger(BiometricsProtoEnums.ACTION_ENUMERATE, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, enrolledList, FaceUtils.getLegacyInstance(mSensorId), mAuthenticatorIds), callback);
-        });
-    }
-
-    @Override
-    public void scheduleInternalCleanup(int sensorId, int userId, ClientMonitorCallback callback) {
-        scheduleInternalCleanup(userId, callback);
-    }
-
-    @Override
-    public void scheduleInvalidateAuthenticatorId(int i, int i1, IInvalidationCallback iInvalidationCallback) {
-        ServiceProvider.super.scheduleInvalidateAuthenticatorId(i, i1, iInvalidationCallback);
-    }
-
-    @Override
-    public void startPreparedClient(int sensorId, int cookie) {
-        mHandler.post(() -> mScheduler.startPreparedClient(cookie));
-    }
-
-    @Override
-    public void dumpProtoState(int sensorId, ProtoOutputStream proto, boolean clearSchedulerBuffer) {
-        final long sensorToken = proto.start(SensorServiceStateProto.SENSOR_STATES);
-
-        proto.write(SensorStateProto.SENSOR_ID, mSensorProperties.sensorId);
-        proto.write(SensorStateProto.MODALITY, SensorStateProto.FACE);
-        proto.write(SensorStateProto.CURRENT_STRENGTH,
-                Utils.getCurrentStrength(mSensorProperties.sensorId));
-        proto.write(SensorStateProto.SCHEDULER, mScheduler.dumpProtoState(clearSchedulerBuffer));
-
-        for (UserInfo user : UserManager.get(mContext).getUsers()) {
-            final int userId = user.getUserHandle().getIdentifier();
-
-            final long userToken = proto.start(SensorStateProto.USER_STATES);
-            proto.write(UserStateProto.USER_ID, userId);
-            proto.write(UserStateProto.NUM_ENROLLED, FaceUtils.getLegacyInstance(mSensorId)
-                    .getBiometricsForUser(mContext, userId).size());
-            proto.end(userToken);
-        }
-
-        proto.write(SensorStateProto.RESET_LOCKOUT_REQUIRES_HARDWARE_AUTH_TOKEN,
-                mSensorProperties.resetLockoutRequiresHardwareAuthToken);
-        proto.write(SensorStateProto.RESET_LOCKOUT_REQUIRES_CHALLENGE,
-                mSensorProperties.resetLockoutRequiresChallenge);
-
-        proto.end(sensorToken);
-    }
-
-    @Override
-    public void dumpProtoMetrics(int sensorId, FileDescriptor fd) {
-    }
-
-    @Override
-    public void dumpInternal(int sensorId, PrintWriter pw) {
-        PerformanceTracker performanceTracker =
-                PerformanceTracker.getInstanceForSensorId(mSensorId);
-
-        JSONObject dump = new JSONObject();
-        try {
-            dump.put("service", TAG);
-
-            JSONArray sets = new JSONArray();
-            for (UserInfo user : UserManager.get(mContext).getUsers()) {
-                final int userId = user.getUserHandle().getIdentifier();
-                final int c = FaceUtils.getLegacyInstance(mSensorId)
-                        .getBiometricsForUser(mContext, userId).size();
-                JSONObject set = new JSONObject();
-                set.put("id", userId);
-                set.put("count", c);
-                set.put("accept", performanceTracker.getAcceptForUser(userId));
-                set.put("reject", performanceTracker.getRejectForUser(userId));
-                set.put("acquire", performanceTracker.getAcquireForUser(userId));
-                set.put("lockout", performanceTracker.getTimedLockoutForUser(userId));
-                set.put("permanentLockout", performanceTracker.getPermanentLockoutForUser(userId));
-                // cryptoStats measures statistics about secure face transactions
-                // (e.g. to unlock password storage, make secure purchases, etc.)
-                set.put("acceptCrypto", performanceTracker.getAcceptCryptoForUser(userId));
-                set.put("rejectCrypto", performanceTracker.getRejectCryptoForUser(userId));
-                set.put("acquireCrypto", performanceTracker.getAcquireCryptoForUser(userId));
-                sets.put(set);
-            }
-
-            dump.put("prints", sets);
-        } catch (JSONException e) {
-            Slog.e(TAG, "dump formatting failure", e);
-        }
-        pw.println(dump);
-        pw.println("HAL deaths since last reboot: " + performanceTracker.getHALDeathCount());
-
-        mScheduler.dump(pw);
-        mUsageStats.print(pw);
-    }
-
-    private void scheduleLoadAuthenticatorIds() {
-        mHandler.post(() -> {
-            for (UserInfo user : UserManager.get(mContext).getAliveUsers()) {
-                int targetUserId = user.id;
-                if (!mAuthenticatorIds.containsKey(Integer.valueOf(targetUserId))) {
-                    scheduleUpdateActiveUserWithoutHandler(targetUserId);
-                }
-            }
-        });
-    }
-
-    void scheduleUpdateActiveUserWithoutHandler(final int targetUserId) {
-        mScheduler.scheduleClientMonitor(new FaceUpdateActiveUserClient(mContext, mLazyDaemon, targetUserId, mContext.getOpPackageName(), mSensorId, createLogger(BiometricsProtoEnums.ACTION_UNKNOWN, BiometricsProtoEnums.CLIENT_UNKNOWN), mBiometricContext, mCurrentUserId, !getEnrolledFaces(mSensorId, targetUserId).isEmpty(), mAuthenticatorIds), new ClientMonitorCallback() {
-            @Override
-            public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
-                if (success) {
-                    mCurrentUserId = targetUserId;
-                }
-            }
-        });
-    }
-
-    private boolean isFaceServiceEnabled() {
-        if (!FaceUnlockUtils.isFaceUnlockSupported()) {
-            return false;
-        }
-        PackageManager pm = mContext.getPackageManager();
-        ResolveInfo info = pm.resolveService(FaceUnlockUtils.getServiceIntent(), 131072);
-        return info != null && info.serviceInfo.isEnabled();
-    }
-
-    public static boolean useCustomFaceUnlockService() {
-        return FaceUnlockUtils.isFaceUnlockSupported();
-    }
-
-    private IFaceService getFaceService(int userId) {
-        if (userId == -10000) {
-            scheduleUpdateActiveUserWithoutHandler(ActivityManager.getCurrentUser());
-        }
-        return mFaceServices.get(mCurrentUserId);
-    }
-
-    void bindFaceAuthService(int userId) {
-        Slog.d(TAG, "bindFaceAuthService " + userId);
-        if (!isFaceServiceEnabled()) {
-            Slog.d(TAG, "FaceService disabled");
-        } else if (mIsServiceBinding) {
-            Slog.d(TAG, "FaceService is binding");
-        } else {
-            if (userId != -10000 && getFaceService(userId) == null) {
-                try {
-                    Intent intent = FaceUnlockUtils.getServiceIntent();
-                    boolean result = mContext.bindServiceAsUser(intent, new FaceServiceConnection(userId), 1, UserHandle.of(userId));
-                    if (result) {
-                        mIsServiceBinding = true;
-                    }
-                } catch (SecurityException e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-    }
-
-    @Override
-    public void dumpHal(int sensorId, FileDescriptor fd, String[] args) {
-    }
-
-    protected void setTestHalEnabled(boolean enabled) {
-        mTestHalEnabled = enabled;
-    }
-
-    @Override
-    public ITestSession createTestSession(int sensorId, ITestSessionCallback callback, String opPackageName) {
-        return new BiometricTestSessionImpl(mContext, mSensorId, callback, this, mHalResultController);
-    }
-
-    public static class HalResultController extends com.android.internal.util.custom.faceunlock.IFaceServiceReceiver.Stub {
-        private final Context mContext;
-        private final Handler mHandler;
-        private final LockoutResetDispatcher mLockoutResetDispatcher;
-        private final LockoutHalImpl mLockoutTracker;
-        private final BiometricScheduler mScheduler;
-        private final int mSensorId;
-        private Callback mCallback;
-
-        HalResultController(int sensorId, Context context, Handler handler, BiometricScheduler scheduler, LockoutHalImpl lockoutTracker, LockoutResetDispatcher lockoutResetDispatcher) {
-            mSensorId = sensorId;
-            mContext = context;
-            mHandler = handler;
-            mScheduler = scheduler;
-            mLockoutTracker = lockoutTracker;
-            mLockoutResetDispatcher = lockoutResetDispatcher;
-        }
-
-        public void setCallback(Callback callback) {
-            mCallback = callback;
-        }
-
-        public void onEnrollResult(int faceId, int userId, int remaining) {
-            mHandler.post(() -> {
-                Face face = new Face(FaceUtils.getLegacyInstance(mSensorId).getUniqueName(mContext, userId), faceId, DEVICE_ID);
-                BaseClientMonitor client = mScheduler.getCurrentClient();
-                if (!(client instanceof FaceEnrollClient)) {
-                    Slog.e(TAG, "onEnrollResult for non-enroll client: " + Utils.getClientName(client));
-                    return;
-                }
-                ((FaceEnrollClient) client).onEnrollResult(face, remaining);
-            });
-        }
-
-        public void onAuthenticated(int faceId, int userId, byte[] token) {
-            mHandler.post(() -> {
-                BaseClientMonitor client = mScheduler.getCurrentClient();
-                if (!(client instanceof AuthenticationConsumer)) {
-                    Slog.e(TAG, "onAuthenticated for non-authentication consumer: " + Utils.getClientName(client));
-                    return;
-                }
-                ((AuthenticationConsumer) client).onAuthenticated(new Face("", faceId, DEVICE_ID), faceId != 0, ArrayUtils.toByteArrayList(token));
-            });
-        }
-
-        public void onAcquired(int userId, int acquiredInfo, int vendorCode) {
-            mHandler.post(() -> {
-                BaseClientMonitor client = mScheduler.getCurrentClient();
-                if (!(client instanceof AcquisitionClient)) {
-                    Slog.e(TAG, "onAcquired for non-acquire client: " + Utils.getClientName(client));
-                    return;
-                }
-                final AcquisitionClient<?> acquisitionClient =
-                        (AcquisitionClient<?>) client;
-                acquisitionClient.onAcquired(acquiredInfo, vendorCode);
-            });
-        }
-
-        public void onError(int error, int vendorCode) {
-            mHandler.post(() -> {
-                BaseClientMonitor client = mScheduler.getCurrentClient();
-                String log = "handleError, client: " +
-                        (client != null ? client.getOwnerString() : null) +
-                        ", error: " +
-                        error +
-                        ", vendorCode: " +
-                        vendorCode;
-                Slog.d(TAG, log);
-                if (!(client instanceof ErrorConsumer)) {
-                    Slog.e(TAG, "onError for non-error consumer: " + Utils.getClientName(client));
-                    return;
-                }
-                ((ErrorConsumer) client).onError(error, vendorCode);
-                if (error == 1) {
-                    Slog.e(TAG, "Got ERROR_HW_UNAVAILABLE");
-                    if (mCallback != null) {
-                        mCallback.onHardwareUnavailable();
-                    }
-                }
-            });
-        }
-
-        public void onRemoved(int[] removed, int userId) {
-            mHandler.post(() -> {
-                BaseClientMonitor client = mScheduler.getCurrentClient();
-                if (!(client instanceof RemovalConsumer)) {
-                    Slog.e(TAG, "onRemoved for non-removal consumer: " + Utils.getClientName(client));
-                    return;
-                }
-                RemovalConsumer removalConsumer = (RemovalConsumer) client;
-                if (removed.length > 0) {
-                    for (int i = 0; i < removed.length; i++) {
-                        int id = removed[i];
-                        Face face = new Face("", id, DEVICE_ID);
-                        int remaining = (removed.length - i) - 1;
-                        Slog.d(TAG, "Removed, faceId: " + id + ", remaining: " + remaining);
-                        removalConsumer.onRemoved(face, remaining);
-                    }
-                } else {
-                    removalConsumer.onRemoved(null, 0);
-                }
-                Settings.Secure.putIntForUser(mContext.getContentResolver(), "face_unlock_re_enroll", 0, -2);
-            });
-        }
-
-        public void onEnumerate(int[] faceIds, int userId) {
-            mHandler.post(() -> {
-                BaseClientMonitor client = mScheduler.getCurrentClient();
-                if (!(client instanceof EnumerateConsumer)) {
-                    Slog.e(TAG, "onEnumerate for non-enumerate consumer: " + Utils.getClientName(client));
-                    return;
-                }
-                EnumerateConsumer enumerateConsumer = (EnumerateConsumer) client;
-                if (faceIds.length > 0) {
-                    for (int i = 0; i < faceIds.length; i++) {
-                        enumerateConsumer.onEnumerationResult(new Face("", faceIds[i], DEVICE_ID), (faceIds.length - i) - 1);
-                    }
-                    return;
-                }
-                enumerateConsumer.onEnumerationResult(null, 0);
-            });
-        }
-
-        public void onLockoutChanged(long duration) {
-            mHandler.post(() -> {
-                int lockoutMode;
-                Slog.d(TAG, "onLockoutChanged: " + duration);
-                if (duration == 0) {
-                    lockoutMode = 0;
-                } else if (duration == -1 || duration == Long.MAX_VALUE) {
-                    lockoutMode = 2;
-                } else {
-                    lockoutMode = 1;
-                }
-                mLockoutTracker.setCurrentUserLockoutMode(lockoutMode);
-                if (duration == 0) {
-                    mLockoutResetDispatcher.notifyLockoutResetCallbacks(mSensorId);
-                }
-            });
-        }
-
-        public interface Callback {
-            void onHardwareUnavailable();
-        }
-    }
-
-    class FaceServiceConnection implements ServiceConnection {
-        private final int mUserId;
-
-        public FaceServiceConnection(int userId) {
-            mUserId = userId;
-        }
-
-        @Override
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            Slog.d(TAG, "FaceService connected : " + mUserId);
-            IFaceService faceService = IFaceService.Stub.asInterface(service);
-            if (faceService != null) {
-                synchronized (mFaceServices) {
-                    try {
-                        faceService.setCallback(mHalResultController);
-                        mFaceServices.put(mUserId, faceService);
-                        mHandler.post(() -> {
-                            scheduleInternalCleanup(mUserId, null);
-                            scheduleGetFeature(mSensorId, new Binder(), mUserId, 1, null, mContext.getOpPackageName());
-                        });
-                    } catch (RemoteException e) {
-                        e.printStackTrace();
-                    }
-                    mIsServiceBinding = false;
-                }
-            }
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName className) {
-            Slog.d(TAG, "FaceService disconnected : " + mUserId);
-            mFaceServices.remove(mUserId);
-            mIsServiceBinding = false;
-            if (mUserId == mCurrentUserId) {
-                mHandler.postDelayed(() -> {
-                    BaseClientMonitor client = mScheduler.getCurrentClient();
-                    if (client instanceof ErrorConsumer) {
-                        ((ErrorConsumer) client).onError(5, 0);
-                    }
-                    bindFaceAuthService(mUserId);
-                    mScheduler.recordCrashState();
-                    mScheduler.reset();
-                }, 100);
-            }
-            mContext.unbindService(this);
-        }
-    }
-
-    private BiometricLogger createLogger(int statsAction, int statsClient) {
-        return new BiometricLogger(mContext, BiometricsProtoEnums.MODALITY_FACE,
-                statsAction, statsClient);
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java
deleted file mode 100644
index 5c01d7b20f6a..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.res.Resources;
-import android.hardware.biometrics.BiometricAuthenticator;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.provider.Settings;
-import android.util.Slog;
-
-import com.android.internal.R;
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.Utils;
-import com.android.server.biometrics.sensors.AuthenticationClient;
-import com.android.server.biometrics.sensors.BiometricNotificationUtils;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.LockoutTracker;
-import com.android.server.biometrics.sensors.face.UsageStats;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-
-import java.util.ArrayList;
-import java.util.function.Supplier;
-
-class FaceAuthenticationClient extends AuthenticationClient<IFaceService> {
-    private static final String TAG = "FaceAuthenticationClient";
-    private final int[] mBiometricPromptIgnoreList;
-    private final int[] mBiometricPromptIgnoreListVendor;
-    private final ContentResolver mContentResolver;
-    private final boolean mCustomHaptics;
-    private final int[] mKeyguardIgnoreList;
-    private final int[] mKeyguardIgnoreListVendor;
-    private final UsageStats mUsageStats;
-    private int mLastAcquire;
-
-    FaceAuthenticationClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, long requestId, ClientMonitorCallbackConverter listener, int targetUserId, long operationId, boolean restricted, String owner, int cookie, boolean requireConfirmation, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, boolean isStrongBiometric, LockoutTracker lockoutTracker, UsageStats usageStats, boolean allowBackgroundAuthentication) {
-        super(context, lazyDaemon, token, listener, targetUserId, operationId, restricted, owner, cookie, requireConfirmation, sensorId, biometricLogger, biometricContext, isStrongBiometric, null /* taskStackListener */, lockoutTracker, allowBackgroundAuthentication, true, false);
-        mUsageStats = usageStats;
-        setRequestId(requestId);
-        Resources resources = getContext().getResources();
-        mBiometricPromptIgnoreList = resources.getIntArray(
-                R.array.config_face_acquire_biometricprompt_ignorelist);
-        mBiometricPromptIgnoreListVendor = resources.getIntArray(
-                R.array.config_face_acquire_vendor_biometricprompt_ignorelist);
-        mKeyguardIgnoreList = resources.getIntArray(
-                R.array.config_face_acquire_keyguard_ignorelist);
-        mKeyguardIgnoreListVendor = resources.getIntArray(
-                R.array.config_face_acquire_vendor_keyguard_ignorelist);
-        ContentResolver contentResolver = context.getContentResolver();
-        mContentResolver = contentResolver;
-        mCustomHaptics = Settings.Global.getInt(contentResolver, "face_custom_success_error", 0) == 1;
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().authenticate(mOperationId);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting auth", e);
-            onError(1, 0);
-            mCallback.onClientFinished(this, false);
-        }
-    }
-
-    @Override
-    protected void handleLifecycleAfterAuth(boolean authenticated) {
-    }
-
-    @Override
-    protected void stopHalOperation() {
-        try {
-            getFreshDaemon().cancel();
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting cancel", e);
-            onError(1, 0);
-            mCallback.onClientFinished(this, false);
-        }
-    }
-
-    @Override
-    public boolean wasUserDetected() {
-        return mLastAcquire != 11 && mLastAcquire != 21;
-    }
-
-    @Override
-    public void onAuthenticated(BiometricAuthenticator.Identifier identifier, boolean authenticated, ArrayList<Byte> token) {
-        super.onAuthenticated(identifier, authenticated, token);
-        mUsageStats.addEvent(new UsageStats.AuthenticationEvent(getStartTimeMs(), System.currentTimeMillis() - getStartTimeMs(), authenticated, 0, 0, getTargetUserId()));
-        mCallback.onClientFinished(this, true);
-    }
-
-    @Override
-    public void onError(int error, int vendorCode) {
-        mUsageStats.addEvent(new UsageStats.AuthenticationEvent(getStartTimeMs(), System.currentTimeMillis() - getStartTimeMs(), false, error, vendorCode, getTargetUserId()));
-        if (error == 16) {
-            BiometricNotificationUtils.showReEnrollmentNotification(getContext());
-        }
-        super.onError(error, vendorCode);
-    }
-
-    private int[] getAcquireIgnorelist() {
-        return isBiometricPrompt() ? mBiometricPromptIgnoreList : mKeyguardIgnoreList;
-    }
-
-    private int[] getAcquireVendorIgnorelist() {
-        return isBiometricPrompt() ? mBiometricPromptIgnoreListVendor : mKeyguardIgnoreListVendor;
-    }
-
-    private boolean shouldSend(int acquireInfo, int vendorCode) {
-        if (acquireInfo == 22) {
-            return !Utils.listContains(getAcquireVendorIgnorelist(), vendorCode);
-        }
-        return !Utils.listContains(getAcquireIgnorelist(), acquireInfo);
-    }
-
-    @Override
-    public void onAcquired(int acquireInfo, int vendorCode) {
-        mLastAcquire = acquireInfo;
-        if (acquireInfo == 13) {
-            BiometricNotificationUtils.showReEnrollmentNotification(getContext());
-        }
-        onAcquiredInternal(acquireInfo, vendorCode, shouldSend(acquireInfo, vendorCode));
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java
deleted file mode 100644
index 6272ce7ec32c..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.hardware.face.Face;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-import android.view.Surface;
-
-import com.android.internal.R;
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.Utils;
-import com.android.server.biometrics.sensors.BiometricUtils;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.EnrollClient;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.function.Supplier;
-
-class FaceEnrollClient extends EnrollClient<IFaceService> {
-    private static final String TAG = "FaceEnrollClient";
-    private final int[] mDisabledFeatures;
-    private final int[] mEnrollIgnoreList = getContext().getResources().getIntArray(R.array.config_face_acquire_enroll_ignorelist);
-    private final int[] mEnrollIgnoreListVendor = getContext().getResources().getIntArray(R.array.config_face_acquire_vendor_enroll_ignorelist);
-    private final Surface mPreviewSurface;
-
-    FaceEnrollClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, byte[] hardwareAuthToken, String owner, BiometricUtils<Face> utils, int[] disabledFeatures, int timeoutSec, Surface previewSurface, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
-        super(context, lazyDaemon, token, listener, userId, hardwareAuthToken, owner, utils, timeoutSec, sensorId, false /* shouldVibrate */, biometricLogger, biometricContext);
-        mDisabledFeatures = Arrays.copyOf(disabledFeatures, disabledFeatures.length);
-        mPreviewSurface = previewSurface;
-    }
-
-    @Override
-    protected boolean hasReachedEnrollmentLimit() {
-        if (mBiometricUtils.getBiometricsForUser(getContext(), getTargetUserId()).size() < getContext().getResources().getInteger(R.integer.config_faceMaxTemplatesPerUser)) {
-            return false;
-        }
-        Slog.w(TAG, "Too many faces registered, user: " + getTargetUserId());
-        return true;
-    }
-
-    @Override
-    public void onAcquired(int acquireInfo, int vendorCode) {
-        boolean shouldSend;
-        if (acquireInfo == 22) {
-            shouldSend = !Utils.listContains(mEnrollIgnoreListVendor, vendorCode);
-        } else {
-            shouldSend = !Utils.listContains(mEnrollIgnoreList, acquireInfo);
-        }
-        onAcquiredInternal(acquireInfo, vendorCode, shouldSend);
-    }
-
-    @Override
-    protected void startHalOperation() {
-        ArrayList<Byte> token = new ArrayList<>();
-        for (byte b : mHardwareAuthToken) {
-            token.add(b);
-        }
-        ArrayList<Integer> disabledFeatures = new ArrayList<>();
-        for (int disabledFeature : mDisabledFeatures) {
-            disabledFeatures.add(disabledFeature);
-        }
-        try {
-            getFreshDaemon().enroll(ArrayUtils.toByteArray(token), mTimeoutSec, ArrayUtils.toIntArray(disabledFeatures));
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting enroll", e);
-            onError(2, 0);
-            mCallback.onClientFinished(this, false);
-        }
-    }
-
-    @Override
-    protected void stopHalOperation() {
-        try {
-            getFreshDaemon().cancel();
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting cancel", e);
-            onError(1, 0);
-            mCallback.onClientFinished(this, false);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java
deleted file mode 100644
index 44c4e6809c07..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.hardware.face.IFaceServiceReceiver;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.internal.util.Preconditions;
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.sensors.BaseClientMonitor;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.GenerateChallengeClient;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.function.Supplier;
-
-class FaceGenerateChallengeClient extends GenerateChallengeClient<IFaceService> {
-    static final int CHALLENGE_TIMEOUT_SEC = 600;
-    private static final ClientMonitorCallback EMPTY_CALLBACK = new ClientMonitorCallback() {
-    };
-    private static final String TAG = "FaceGenerateChallengeClient";
-    private final long mCreatedAt;
-    private Long mChallengeResult;
-    private List<IFaceServiceReceiver> mWaiting = new ArrayList();
-
-    FaceGenerateChallengeClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, long now) {
-        super(context, lazyDaemon, token, listener, userId, owner, sensorId, biometricLogger, biometricContext);
-        mCreatedAt = now;
-    }
-
-    @Override
-    protected void startHalOperation() {
-        mChallengeResult = null;
-        try {
-            try {
-                mChallengeResult = getFreshDaemon().generateChallenge(600);
-                sendChallengeResult(getListener(), mCallback);
-                for (IFaceServiceReceiver receiver : mWaiting) {
-                    sendChallengeResult(new ClientMonitorCallbackConverter(receiver), EMPTY_CALLBACK);
-                }
-            } catch (RemoteException e) {
-                Slog.e(TAG, "generateChallenge failed", e);
-                mCallback.onClientFinished(this, false);
-            }
-        } finally {
-            mWaiting = null;
-        }
-    }
-
-    public long getCreatedAt() {
-        return mCreatedAt;
-    }
-
-    public void reuseResult(IFaceServiceReceiver receiver) {
-        List<IFaceServiceReceiver> list = mWaiting;
-        if (list != null) {
-            list.add(receiver);
-        } else {
-            sendChallengeResult(new ClientMonitorCallbackConverter(receiver), EMPTY_CALLBACK);
-        }
-    }
-
-    private void sendChallengeResult(ClientMonitorCallbackConverter receiver, ClientMonitorCallback ownerCallback) {
-        Preconditions.checkState(mChallengeResult != null, "result not available");
-        try {
-            receiver.onChallengeGenerated(getSensorId(), getTargetUserId(), mChallengeResult);
-            ownerCallback.onClientFinished(this, true);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception", e);
-            ownerCallback.onClientFinished(this, false);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java
deleted file mode 100644
index 901bf581fa13..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.sensors.BaseClientMonitor;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.HalClientMonitor;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-
-import java.util.function.Supplier;
-
-public class FaceGetFeatureClient extends HalClientMonitor<IFaceService> {
-    private static final String TAG = "FaceGetFeatureClient";
-    private final int mFaceId;
-    private final int mFeature;
-    private boolean mValue;
-
-    FaceGetFeatureClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, int feature, int faceId) {
-        super(context, lazyDaemon, token, listener, userId, owner, 0, sensorId, biometricLogger, biometricContext);
-        mFeature = feature;
-        mFaceId = faceId;
-    }
-
-    @Override
-    public void unableToStart() {
-        try {
-            if (getListener() != null) {
-                getListener().onFeatureGet(false, new int[0], new boolean[0]);
-            }
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to send error", e);
-        }
-    }
-
-    @Override
-    public void start(ClientMonitorCallback callback) {
-        super.start(callback);
-        startHalOperation();
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            boolean result = getFreshDaemon().getFeature(mFeature, mFaceId);
-            int[] features = {mFeature};
-            boolean[] featureState = {result};
-            mValue = result;
-            if (getListener() != null) {
-                getListener().onFeatureGet(result, features, featureState);
-            }
-            mCallback.onClientFinished(this, true);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to getFeature", e);
-            mCallback.onClientFinished(this, false);
-        }
-    }
-
-    public boolean getValue() {
-        return mValue;
-    }
-
-    @Override
-    public int getProtoEnum() {
-        return 9;
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java
deleted file mode 100644
index 662886d79ca5..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.hardware.face.Face;
-import android.os.IBinder;
-
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.sensors.BiometricUtils;
-import com.android.server.biometrics.sensors.InternalCleanupClient;
-import com.android.server.biometrics.sensors.InternalEnumerateClient;
-import com.android.server.biometrics.sensors.RemovalClient;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-
-import java.util.List;
-import java.util.Map;
-import java.util.function.Supplier;
-
-class FaceInternalCleanupClient extends InternalCleanupClient<Face, IFaceService> {
-    FaceInternalCleanupClient(Context context, Supplier<IFaceService> lazyDaemon, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, List<Face> enrolledList, BiometricUtils<Face> utils, Map<Integer, Long> authenticatorIds) {
-        super(context, lazyDaemon, userId, owner, sensorId, biometricLogger, biometricContext, enrolledList, utils, authenticatorIds);
-    }
-
-    @Override
-    protected InternalEnumerateClient<IFaceService> getEnumerateClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int userId, String owner, List<Face> enrolledList, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
-        return new FaceInternalEnumerateClient(context, lazyDaemon, token, userId, owner, enrolledList, utils, sensorId, biometricLogger, biometricContext);
-    }
-
-    @Override
-    protected RemovalClient<Face, IFaceService> getRemovalClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int biometricId, int userId, String owner, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, Map<Integer, Long> authenticatorIds) {
-        return new FaceRemovalClient(context, lazyDaemon, token, null, biometricId, userId, owner, utils, sensorId, biometricLogger, biometricContext, authenticatorIds);
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java
deleted file mode 100644
index 68b1d3b1f055..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.hardware.face.Face;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.sensors.BiometricUtils;
-import com.android.server.biometrics.sensors.InternalEnumerateClient;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-
-import java.util.List;
-import java.util.function.Supplier;
-
-class FaceInternalEnumerateClient extends InternalEnumerateClient<IFaceService> {
-    private static final String TAG = "FaceInternalEnumerateClient";
-
-    FaceInternalEnumerateClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int userId, String owner, List<Face> enrolledList, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
-        super(context, lazyDaemon, token, userId, owner, enrolledList, utils, sensorId, biometricLogger, biometricContext);
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().enumerate();
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting enumerate", e);
-            mCallback.onClientFinished(this, false);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java
deleted file mode 100644
index 61a7976fc0c6..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.hardware.face.Face;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.sensors.BiometricUtils;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.RemovalClient;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-
-import java.util.Map;
-import java.util.function.Supplier;
-
-class FaceRemovalClient extends RemovalClient<Face, IFaceService> {
-    private static final String TAG = "FaceRemovalClient";
-    private final int mBiometricId;
-
-    FaceRemovalClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int biometricId, int userId, String owner, BiometricUtils<Face> utils, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, Map<Integer, Long> authenticatorIds) {
-        super(context, lazyDaemon, token, listener, userId, owner, utils, sensorId, biometricLogger, biometricContext, authenticatorIds);
-        mBiometricId = biometricId;
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().remove(mBiometricId);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Remote exception when requesting remove", e);
-            mCallback.onClientFinished(this, false);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java
deleted file mode 100644
index 5915f81056f5..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.sensors.BaseClientMonitor;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.HalClientMonitor;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-
-import java.util.function.Supplier;
-
-class FaceResetLockoutClient extends HalClientMonitor<IFaceService> {
-    private static final String TAG = "FaceResetLockoutClient";
-    private final byte[] mHardwareAuthToken;
-
-    FaceResetLockoutClient(Context context, Supplier<IFaceService> lazyDaemon, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, byte[] hardwareAuthToken) {
-        super(context, lazyDaemon, null, null, userId, owner, 0, sensorId, biometricLogger, biometricContext);
-        mHardwareAuthToken = hardwareAuthToken.clone();
-    }
-
-    @Override
-    public void unableToStart() {
-    }
-
-    @Override
-    public void start(ClientMonitorCallback callback) {
-        super.start(callback);
-        startHalOperation();
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().resetLockout(mHardwareAuthToken);
-            mCallback.onClientFinished(this, true);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to reset lockout", e);
-            mCallback.onClientFinished(this, false);
-        }
-    }
-
-    @Override
-    public int getProtoEnum() {
-        return 12;
-    }
-
-    @Override
-    public boolean interruptsPrecedingClients() {
-        return true;
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java
deleted file mode 100644
index 7939bf3d75b1..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.sensors.RevokeChallengeClient;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-
-import java.util.function.Supplier;
-
-class FaceRevokeChallengeClient extends RevokeChallengeClient<IFaceService> {
-    private static final String TAG = "FaceRevokeChallengeClient";
-
-    FaceRevokeChallengeClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext) {
-        super(context, lazyDaemon, token, userId, owner, sensorId, biometricLogger, biometricContext);
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().revokeChallenge();
-            mCallback.onClientFinished(this, true);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "revokeChallenge failed", e);
-            mCallback.onClientFinished(this, false);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java
deleted file mode 100644
index 174cfca92982..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.sensors.BaseClientMonitor;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
-import com.android.server.biometrics.sensors.HalClientMonitor;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-
-import java.util.function.Supplier;
-
-class FaceSetFeatureClient extends HalClientMonitor<IFaceService> {
-    private static final String TAG = "FaceSetFeatureClient";
-    private final boolean mEnabled;
-    private final int mFaceId;
-    private final int mFeature;
-    private final byte[] mHardwareAuthToken;
-
-    FaceSetFeatureClient(Context context, Supplier<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, int feature, boolean enabled, byte[] hardwareAuthToken, int faceId) {
-        super(context, lazyDaemon, token, listener, userId, owner, 0, sensorId, biometricLogger, biometricContext);
-        mFeature = feature;
-        mEnabled = enabled;
-        mFaceId = faceId;
-        mHardwareAuthToken = hardwareAuthToken.clone();
-    }
-
-    @Override
-    public void unableToStart() {
-        try {
-            getListener().onFeatureSet(false, mFeature);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to send error", e);
-        }
-    }
-
-    @Override
-    public void start(ClientMonitorCallback callback) {
-        super.start(callback);
-        startHalOperation();
-    }
-
-    @Override
-    protected void startHalOperation() {
-        try {
-            getFreshDaemon().setFeature(mFeature, mEnabled, mHardwareAuthToken, mFaceId);
-            getListener().onFeatureSet(true, mFeature);
-            mCallback.onClientFinished(this, true);
-        } catch (RemoteException e) {
-            Slog.e(TAG, "Unable to set feature: " + mFeature + " to enabled: " + mEnabled, e);
-            mCallback.onClientFinished(this, false);
-        }
-    }
-
-    @Override
-    public int getProtoEnum() {
-        return 8;
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java
deleted file mode 100644
index 163c24bd7934..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.server.biometrics.sensors.BaseClientMonitor;
-import com.android.server.biometrics.sensors.ClientMonitorCallback;
-import com.android.server.biometrics.sensors.HalClientMonitor;
-import com.android.server.biometrics.log.BiometricContext;
-import com.android.server.biometrics.log.BiometricLogger;
-
-import java.util.Map;
-import java.util.function.Supplier;
-
-class FaceUpdateActiveUserClient extends HalClientMonitor<IFaceService> {
-    private static final String FACE_DATA_DIR = "facedata";
-    private static final String TAG = "FaceUpdateActiveUserClient";
-    private final Map<Integer, Long> mAuthenticatorIds;
-    private final int mCurrentUserId;
-    private final boolean mHasEnrolledBiometrics;
-
-    FaceUpdateActiveUserClient(Context context, Supplier<IFaceService> lazyDaemon, int userId, String owner, int sensorId, BiometricLogger biometricLogger, BiometricContext biometricContext, int currentUserId, boolean hasEnrolledBIometrics, Map<Integer, Long> authenticatorIds) {
-        super(context, lazyDaemon, null, null, userId, owner, 0, sensorId, biometricLogger, biometricContext);
-        mCurrentUserId = currentUserId;
-        mHasEnrolledBiometrics = hasEnrolledBIometrics;
-        mAuthenticatorIds = authenticatorIds;
-    }
-
-    @Override
-    public void start(ClientMonitorCallback callback) {
-        super.start(callback);
-        if (mCurrentUserId == getTargetUserId()) {
-            Slog.d(TAG, "Already user: " + mCurrentUserId + ", refreshing authenticatorId");
-            try {
-                mAuthenticatorIds.put(getTargetUserId(), mHasEnrolledBiometrics ? (long) getFreshDaemon().getAuthenticatorId() : 0);
-            } catch (RemoteException e) {
-                Slog.e(TAG, "Unable to refresh authenticatorId", e);
-            }
-            callback.onClientFinished(this, true);
-            return;
-        }
-        startHalOperation();
-    }
-
-    @Override
-    public void unableToStart() {
-    }
-
-    @Override
-    protected void startHalOperation() {
-        mCallback.onClientFinished(this, false);
-    }
-
-    @Override
-    public int getProtoEnum() {
-        return 1;
-    }
-}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java
deleted file mode 100644
index 5b8a9eb24629..000000000000
--- a/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
-* Copyright (C) 2022 The Pixel Experience Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package com.android.server.biometrics.sensors.face.custom;
-
-import android.content.Context;
-import android.hardware.face.Face;
-import android.os.RemoteException;
-import android.util.Slog;
-
-import com.android.internal.util.custom.faceunlock.IFaceService;
-import com.android.internal.util.custom.faceunlock.IFaceServiceReceiver;
-import com.android.server.biometrics.sensors.face.FaceUtils;
-
-import java.util.List;
-
-class TestHal extends IFaceService.Stub {
-    private static final String TAG = "FaceService.TestHal";
-    private final Context mContext;
-    private final int mSensorId;
-    private final int mUserId;
-    private IFaceServiceReceiver mCallback;
-
-    TestHal(int userId, Context context, int sensorId) {
-        mUserId = userId;
-        mContext = context;
-        mSensorId = sensorId;
-    }
-
-    @Override
-    public void setCallback(IFaceServiceReceiver clientCallback) throws RemoteException {
-        mCallback = clientCallback;
-    }
-
-    @Override
-    public int revokeChallenge() {
-        return 0;
-    }
-
-    @Override
-    public int getAuthenticatorId() throws RemoteException {
-        return 0;
-    }
-
-    @Override
-    public boolean getFeature(int i, int i1) throws RemoteException {
-        return false;
-    }
-
-    @Override
-    public int getFeatureCount() throws RemoteException {
-        return 0;
-    }
-
-    @Override
-    public long generateChallenge(int i) throws RemoteException {
-        Slog.w(TAG, "generateChallenge");
-        return 0;
-    }
-
-    @Override
-    public void resetLockout(byte[] bytes) throws RemoteException {
-    }
-
-    @Override
-    public void setFeature(int i, boolean b, byte[] bytes, int i1) throws RemoteException {
-    }
-
-    @Override
-    public int enumerate() throws RemoteException {
-        Slog.w(TAG, "enumerate");
-        if (mCallback != null) {
-            mCallback.onEnumerate(new int[0], 0);
-        }
-        return 0;
-    }
-
-    @Override
-    public void enroll(byte[] bytes, int i, int[] ints) throws RemoteException {
-        Slog.w(TAG, "enroll");
-    }
-
-    @Override
-    public void authenticate(long l) throws RemoteException {
-        Slog.w(TAG, "authenticate");
-    }
-
-    @Override
-    public void cancel() throws RemoteException {
-        if (mCallback != null) {
-            mCallback.onError(5, 0);
-        }
-    }
-
-    @Override
-    public void remove(int faceId) throws RemoteException {
-        if (mCallback != null) {
-            Slog.d(TAG, " remove : faceId = " + faceId);
-            if (faceId == 0) {
-                List<Face> faces = FaceUtils.getInstance(mSensorId).getBiometricsForUser(mContext, mUserId);
-                if (faces.size() <= 0) {
-                    mCallback.onError(6, 0);
-                    return;
-                }
-                int[] faceIds = new int[faces.size()];
-                for (int i = 0; i < faces.size(); i++) {
-                    faceIds[i] = faces.get(i).getBiometricId();
-                }
-                mCallback.onRemoved(faceIds, mUserId);
-                return;
-            }
-            mCallback.onRemoved(new int[]{faceId}, mUserId);
-        }
-    }
-}
diff --git a/services/core/java/com/android/server/policy/PermissionPolicyService.java b/services/core/java/com/android/server/policy/PermissionPolicyService.java
index f0d764fe716f..b56e1120f16a 100644
--- a/services/core/java/com/android/server/policy/PermissionPolicyService.java
+++ b/services/core/java/com/android/server/policy/PermissionPolicyService.java
@@ -103,8 +103,6 @@ import com.android.server.wm.ActivityInterceptorCallback;
 import com.android.server.wm.ActivityInterceptorCallback.ActivityInterceptorInfo;
 import com.android.server.wm.ActivityTaskManagerInternal;
 
-import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -937,12 +935,6 @@ public final class PermissionPolicyService extends SystemService {
                             permissionInfo.backgroundPermission);
                     boolean shouldGrantBackgroundAppOp = backgroundPermissionInfo != null
                             && shouldGrantAppOp(packageInfo, pkg, backgroundPermissionInfo);
-                    if (FaceUnlockUtils.getServicePackageName().equals(packageName) &&
-                            FaceUnlockUtils.isFaceUnlockSupported() &&
-                            "android.permission.CAMERA".equals(permissionInfo.name) &&
-                            packageInfo.applicationInfo.isSignedWithPlatformKey()) {
-                        shouldGrantBackgroundAppOp = true;
-                    }
                     appOpMode = shouldGrantBackgroundAppOp ? MODE_ALLOWED : MODE_FOREGROUND;
                 } else {
                     appOpMode = MODE_ALLOWED;
